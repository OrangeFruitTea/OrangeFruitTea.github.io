<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/2c5de2c19acc/"/>
    <url>/2025-08-11/2c5de2c19acc/</url>
    
    <content type="html"><![CDATA[<p>这是你的新<em>仓库</em>。</p><p>写点笔记，[[创建链接]]，或者试一试<a href="https://help.obsidian.md/Plugins/Importer">导入器</a>插件!</p><p>当你准备好了，就将该笔记文件删除，使这个仓库为你所用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/e3482dd01707/"/>
    <url>/2025-08-11/e3482dd01707/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>Java中创建线程分为多种方式：</p><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>这是创建线程的一种简单方式。继承自<code>Thread</code>类并重写<code>run()</code>方法，则可以自定义一个简单的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExtending</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>实现<code>Runnable</code>接口是另一种创建线程的方式。在实现<code>run()</code>方法后还需要将该类实例作为参数传递给<code>Thread</code>类的构造函数。该方法的优点是避免了单继承的局限性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExecute</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现Callable与Future"><a href="#实现Callable与Future" class="headerlink" title="实现Callable与Future"></a>实现Callable与Future</h2><p><code>Callable</code>接口与<code>Runnable</code>类似，但其<code>call()</code>方法可以有返回值，并且可以抛出异常。结合<code>Future</code>接口使用可以获取线程执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExecute</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executores.newSingleThreadExecutor();<br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>Future&lt;Integer&gt; future = executor.submit(myCallable);<br><span class="hljs-keyword">try</span> &#123;<br>Integer res future.get();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>executor.shutdown();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h1><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>用于修饰方法或代码块，保证同一时刻只有一个线程可以调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 同步方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br><span class="hljs-comment">// 同步代码块</span><br><span class="hljs-comment">// 用于控制线程同步的锁对象，通过锁定该对象实现同步互斥</span><br><span class="hljs-comment">// 通常选择this/类对象（所有实例共享一个锁）/专门的锁对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p><code>Lock</code>接口及其实现类（例如<code>ReentrantLock</code>）来实现同步机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/3b33cd8361ee/"/>
    <url>/2025-08-11/3b33cd8361ee/</url>
    
    <content type="html"><![CDATA[<p><strong>获取字符串长度</strong> </p><p><strong>截取子字符串</strong> </p><p><strong>查找字符串</strong> </p><p><strong><code>indexOf</code>方法</strong> </p><p><strong><code>matches</code>方法</strong></p><p><strong>字符串比较</strong> </p><p><strong>字符串分割</strong> </p><p><strong>数字与字符串的转换</strong> </p><p><strong>将对象转换为字符串</strong> </p><p><strong>获取指定索引上的字符</strong> </p><p><strong>获取字符串的字节表现形式</strong> </p><p><strong>将字符串转换为大&#x2F;小写</strong> </p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java 字符串底层]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/fd261929bf26/"/>
    <url>/2025-08-11/fd261929bf26/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串在Java的内部表示"><a href="#字符串在Java的内部表示" class="headerlink" title="字符串在Java的内部表示"></a>字符串在Java的内部表示</h1><p>在Java 9之前，字符串（String）在JVM内部使用UTF-16编码的字节表示。UTF-16使用2个字节表示单个字符。<br>而从Java 9开始，JVM可使用一种称为紧凑字符串的新特性来优化字符串。该特性允许JVM检测字符串是否包含ISO-8859-1&#x2F;Latin-1字符，如果是，字符串内部将仅使用1字节表示单个字符。<br>字符串创建时，JVM就会检测字符串是否可以表示位紧凑字符串。为了安全，字符串一旦创建就不可改变。</p><h1 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h1><p>Java中的字符串本质上是一个对象，因此需要使用<code>new</code>运算符来创建一个<code>String</code>对象。不过平时在创建字符串时，会习惯用直接赋值的方式创建。使用这种简短方式创建字符时，编译器会在内部计算出如何创建给定文本的<code>String</code>对象。</p><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>如果使用相同的字面量进行多次<code>String</code>变量声明，JVM在内存中可能只会创建单个<code>String</code>实例，初始化为相同字面量的不同变量将会指向内存中的那个相同<code>String</code>实例。这个共享发生在运行时，而不是编译时的功能。<br>如果希望两个字面值相同的<code>String</code>变量指向不同的对象，通过<code>new Strign</code>创建字符串即可。</p><h1 id="字符串的不变性"><a href="#字符串的不变性" class="headerlink" title="字符串的不变性"></a>字符串的不变性</h1><p>Java中对String类型的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String</code>类被final关键字修饰，表示该类无法被继承，而存储<code>String</code>类的数组同样被final修饰，表示<code>String</code>对象无法被修改。这样设计一是能保证<code>String</code>对象的安全性，避免字符串被修改，二是能通过字符串常量池减少同一个值的字符串对象的重复创建。</p><h1 id="字符串的更改"><a href="#字符串的更改" class="headerlink" title="字符串的更改"></a>字符串的更改</h1><p>由于<code>String</code>类型不可变，因此不支持像数组一样用<code>[]</code>访问其中的字符，且需要使用<code>toCharArray</code>方法转化为<code>char[]</code>类型，再转回<code>String</code>类型才能修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s1[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">chars</span> <span class="hljs-operator">=</span> s1.toCharArray();<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br></code></pre></td></tr></table></figure><p>即使这样修改后，旧的String变量也并没有发生修改。由于String不可变，再使用例如<code>replace</code>，<code>trim</code>等方法时，返回的都是新字符串对象。</p><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><p>可以使用<code>+</code>运算符对两个字符串进行拼接，由于字符串的不变性，因此将两个字符串拼接时，返回的是新的字符串对象。<br>拼接字符串这个功能会被编译为<code>StringBuilder</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><br><span class="hljs-comment">// String s3 = s1 + s2 会被转化为如下方式：</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s1).append(s2).toString();<br></code></pre></td></tr></table></figure><p>在循环中使用这样的字符串拼接时，会在每次迭代时都创建一个新的<code>StringBuilder</code>，以及由于<code>toString()</code>方法创建的<code>String</code>对象。并且每次创建<code>StringBuilder</code>对象时，都会将字符串复制到<code>StringBuilder</code>中，复制时间也会随循环次数增大而增大。<br>正确的方式时在循环外创建<code>StringBuilder</code>实例，在循环内替代<code>+</code>进行字符串拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;...&#125;;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (String str : strings) &#123;<br>temp.append(str);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> temp.toString();<br></code></pre></td></tr></table></figure><p>如果在并发编程中拼接<code>String</code>对象，可以使用线程安全的<code>StringBuffer</code>，但由于涉及锁竞争，性能会稍差一些。</p><h1 id="字符串的相等比较"><a href="#字符串的相等比较" class="headerlink" title="字符串的相等比较"></a>字符串的相等比较</h1><p>Java字符串相等比较应使用<code>String</code>对象的<code>equals</code>方法，而不是使用<code>==</code>比较。<code>==</code>比较的是两个字符串是否是完全相同的对象，而值相等的对象不一定是同一个对象。但当一个字符串对象为空时，再调用<code>equals()</code>方法会导致空指针异常。正确的判断字符串对象是不是空的，应该先检测它是不是 null，再看是不是空字符。<br>常用的Guava库与<code>Apache Common Lang</code>库都有该功能，分别是<code>isNullOfEmpty()</code>和<code>isEmpty()</code>。</p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java 字符串常用操作]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/c08ee9fdab93/"/>
    <url>/2025-08-11/c08ee9fdab93/</url>
    
    <content type="html"><![CDATA[<p>Java中的类型转换可分为以下几类：</p><ul><li>自动类型转换（隐式转换）</li><li>强制类型转换（显式转换）</li><li>引用类型转换（详见[[Java 多态与多态的类型转换]]）</li><li>装箱与拆箱</li><li>字符串与基本数据类型的转换</li><li>自定义类型转换（通过构造函数或方法）</li></ul><h1 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h1><p>是指在安全情况下，由编译器自动完成的类型转换。这种转换不会丢失数据。</p><h2 id="基本数据类型的自动转换"><a href="#基本数据类型的自动转换" class="headerlink" title="基本数据类型的自动转换"></a>基本数据类型的自动转换</h2><p>基本数据类型的自动转换遵循小范围到大范围的转换：<br><code>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code><br><code>1 -&gt; 2 -&gt; 4-&gt; 8 -&gt; 4 -&gt; 8（字节）</code><br>由于<code>float</code>是32位的单精度浮点数，而<code>long</code>是64位的整数，因此<code>long -&gt; float</code>的自动转换可能会导致精度损失。<br>如果表达式中存在多个数据类型，编译器会先将所有操作数提升到最宽的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> b + s; <span class="hljs-comment">// b与s都被提升为int</span><br></code></pre></td></tr></table></figure><p>在调用方法时，如果参数类型与方法签名不完全匹配，但可以自动转换时，编译器会自动转换。</p><h2 id="引用类型的自动转换"><a href="#引用类型的自动转换" class="headerlink" title="引用类型的自动转换"></a>引用类型的自动转换</h2><p>引用类型的自动转换主要发生在<a href="Java%20%E5%A4%9A%E6%80%81%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">向上转型</a>中，即将子类对象赋值给父类类型的引用变量。</p><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>是指在可能丢失数据的情况下，由程序员显式进行的类型转换。这种转换需要强制类型转换运算符。<br>基本数据类型之间的强制转换可能导致数据丢失，例如<code>double</code>、<code>float</code>转化为<code>long</code>、<code>int</code>时会舍去小数部分；强制将<code>long</code>转换为<code>int</code>时会仅截取低N位，丢失高位数据。<br>引用类型的转换主要用于<a href="Java%20%E5%A4%9A%E6%80%81%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">向下转型</a>中，即将父类类型的引用变量强制转换为子类类型。</p><h1 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h1><p>是Java 5引入的特性，用于简化代码，自动在基本数据类型与对应的包装类之间进行转换。<br>装箱是指将基本数据类型转换为包装类，拆箱是指将包装类自动转换为对应的基本数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动将 int 转换为 Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">// 自动将 Integer 转换为 int</span><br></code></pre></td></tr></table></figure><p>装箱与拆箱操作设计对象的创建和方法调用，会导致额外的性能开销。<br>如果包装类对象为空，拆箱时会出现<code>NullPointerException</code>.</p><h1 id="字符串与基本数据类型的转换"><a href="#字符串与基本数据类型的转换" class="headerlink" title="字符串与基本数据类型的转换"></a>字符串与基本数据类型的转换</h1><p>Java提供了多种在字符串与基本数据类型之间转换的方法，例如使用包装里的<code>parseInt</code>、<code>parseFloat</code>等静态方法，基本数据类型转字符串则可以使用<code>String.valueOf</code>或字符串连接操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Double.parseDouble(str);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> String.valueOf(num);<br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + num;<br></code></pre></td></tr></table></figure><p>当字符串格式不正确时，<code>parse</code>函数会抛出<code>NumberFormatException</code>。</p><h1 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h1><p>可通过构造函数或静态工厂方法实现自定义类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-type">int</span> x, y;<br>Point(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-built_in">this</span>.x = x; <span class="hljs-built_in">this</span>.y = y; &#125;<br><br>Point(String s) &#123;<br>String[] parts = s.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-built_in">this</span>.x = Integer.parseInt(parts[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">this</span>.y = Integer.parseInt(parts[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">static</span> Point <span class="hljs-title function_">fromString</span><span class="hljs-params">(String s)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(s); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java 多态与多态的类型转换]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/a9efbe6b6860/"/>
    <url>/2025-08-11/a9efbe6b6860/</url>
    
    <content type="html"><![CDATA[<h2 id="Java的方法调用"><a href="#Java的方法调用" class="headerlink" title="Java的方法调用"></a>Java的方法调用</h2><p>Java的class文件的编译过程里不包括传统编译过程的链接阶段。class文件中的方法以符号引用的形式存储，而非方法的入口地址。该特定使得Java具有强大的动态拓展能力，但同时增加了Java方法调用过程的复杂性。Java方法需要在类加载期间或者运行期间才能确定真正的入口地址，即把符号引用转为直接引用。即因为多态的存在，程序在判断方法调用的版本时需要进行一定的选择。<br>JVM中提供5中方法调用的字节码指令：</p><ul><li><code>invokestatic</code>：调用静态方法。</li><li><code>invokespecial</code>：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法与父类方法。 </li><li><code>invokevirutal</code>：调用虚方法。</li><li><code>invokeinterface</code>：调用接口方法，会在运行时确定一个实现此接口的对象。</li><li><code>invokedynamic</code>：现在运行时动态解析出调用点限定符所用的方法，然后再执行该方法。<br>只要能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都可以在类加载过程中的解析阶段确定唯一的调用版本，符合这个条件的方法有：静态方法、私有方法、实例构造器和父类方法，它们在类加载过程中的解析阶段就会将符号引用解析为该方法的直接引用。这些方法可被称为非虚方法（也就是不涉及多态的方法）。<br>因此方法调用可以分为两种，一种是类加载过程中的解析阶段完成的，另一种要在运行时完成，叫作<strong>分派</strong>，根据查找方法方式不同分为静态分派与动态分派。</li></ul><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>编译器会根据方法参数的静态类型作为判断依据来选择合适的函数重载版本。<br>静态分派是Java实现重载的本质，JVM通过静态类型来选择具体方法，完成符号引用到直接引用的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span> &#123;&#125;<br><br><span class="hljs-comment">// 不同参数的函数重载</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(Human human)</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(Human human)</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(Human human)</span> &#123;...&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 这两个对象的静态类型是Human</span><br><span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br><span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();<br><br>func(man);<br>func(woman);<br><span class="hljs-comment">// 修改静态类型</span><br>func((Man) man);<br>func((Woman) woman);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派与子类重写父类方法有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Human</span> <span class="hljs-variable">man</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();  <br><span class="hljs-type">Human</span> <span class="hljs-variable">woman</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();  <br>man.func();  <br>woman.func();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JVM如何实现动态分派"><a href="#JVM如何实现动态分派" class="headerlink" title="JVM如何实现动态分派"></a>JVM如何实现动态分派</h3><p>由于动态分派这一操作十分频繁，且动态分派的方法版本选择需要在运行时从类的方法元数据中搜索合适的目标方法，因此虚拟机会对该操作进行优化。常用的方法是为类在方法区中建立一个虚方法表（调用接口方法时也会有类似的接口方法表），使用虚方法表中的索引来提到元数据查找以提高性能。<br>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没被重写，那么子类的虚方法表的地址入口，与父类相同方法的一致，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。<br>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中的索引相同（位于数组的同个索引），这样当类型变换时，程序只需要改变虚方法表的引用，而不需要改变方法调用的索引。这样可以大大简化程序的实现逻辑，提高效率。<br>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java 多态与多态的类型转换]]<br>[[Java 静态类型]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/df05937f9dac/"/>
    <url>/2025-08-11/df05937f9dac/</url>
    
    <content type="html"><![CDATA[<h1 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h1><p>多态在Java中可以解释为：<strong>不同的对象调用相同方法时，会产生不同的行为。</strong> 这是面向对象过程中一个重要特性，能提高代码的灵活性与扩展性。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Java 中的类对象类型转换分为向上转型和向下转型。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>将实际类型为子类的对象强制转换为父类类型，称为向上转型。<br><strong>特点</strong>：</p><ul><li>向上转型后，子类特有的变量和方法将无法直接访问。</li><li>如果子类重写了父类的方法或拥有同名变量，调用时会优先使用子类的版本；如果子类中不存在，才会调用父类的版本。<br><strong>用途</strong>：<br>向上转型常用于将父类作为方法参数，以处理具有相同逻辑的不同子类对象，从而避免编写额外的方法。</li></ul><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>将父类引用还原为子类对象，称为向下转型。<br>向下转型存在风险，因为父类引用可能指向错误的子类类型，导致类型转换错误。Java 引入了 <code>instanceof</code> 关键字，用于检查对象的实际类型。如果 <code>instanceof</code> 表达式为真，则可以安全地进行类型转换。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Dog) &#123;<br><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) animal;<br><span class="hljs-comment">// 处理 Dog 类型的逻辑</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Cat) &#123;<br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;<br><span class="hljs-comment">// 处理 Cat 类型的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态的实现条件"><a href="#多态的实现条件" class="headerlink" title="多态的实现条件"></a>多态的实现条件</h2><p>多态的实现有三个条件：</p><ul><li>必须依赖于继承，即存在父类和子类的关系。</li><li>子类需要重写父类的同名方法。只有当子类重写了父类的方法时，多态行为才会体现出来。</li><li>子类对象的静态类型必须是父类的引用类型。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// 父类引用指向子类对象</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[JVM如何实现Java多态]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/4c5eb32834bb/"/>
    <url>/2025-08-11/4c5eb32834bb/</url>
    
    <content type="html"><![CDATA[<p>程序计数器、虚拟机栈和本地方法栈三个区域都随线程生灭，栈中的栈帧的出入栈操作也同样简单，因此当方法或线程结束后，对应的内存自然跟着回收，不需要过多考虑如何内存管理。但动态分配的堆与方法区则并非如此：一个接口的多个实现类的内存可能不一样，一个方法执行的不同分支所需内存也可能不一样，只有处于运行期间，程序才能了解自己要创建什么类型的对象，创建多少个对象，因此这部分的内存分配与回收时动态的，需要一个垃圾收集器（GC）来管理内存。</p><h1 id="现代JVM的GC"><a href="#现代JVM的GC" class="headerlink" title="现代JVM的GC"></a>现代JVM的GC</h1><p>现代JVM中将堆内存分为了新生代与老年代，前者通常使用标记-复制算法，保证交稿的效率，并且无内存碎片问题；后者通常使用标记-整理算法，避免内存碎片。<br>为了减少程序暂停时间，现代JVM引入了并发和并行GC：</p><ul><li><strong>并发GC</strong>：如CMS（Concurrent Mark-Sweep）收集器，将GC过程分为多个阶段，部分阶段允许用户线程与GC线程并发执行，以减少停顿时间。</li><li><strong>并行GC</strong>：使用多个线程同时进行GC，例如Parallel GC会同时在新生代与老年代分别使用不同算法。<br>每一代JVM GC都将程序暂停时间缩短作为重要的目标。<br>  <em>下文为HotSpot虚拟机的GC设置</em>。<br>默认情况下，虚拟机堆内存中新生代、老年代所占空间比例为1：2。</li></ul><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>绝大多数新创建的对象都会分配到堆中的新生代区域，该区域触发的GC称为Minor GC。<br><strong>· 1个伊甸园空间（Eden）</strong><br><strong>· 2个幸存者空间（From Survivor、To Survivor）</strong><br>默认情况下，新生代空间的分配：<strong>Eden : From : To</strong> &#x3D; <strong>8 : 1 : 1</strong><br>IBM有过一项针对新生代的研究，结论是大多数情况下，新生代区域里的对象有98%活不过第一次GC，因此不使用1：1比例来实现复制算法。<br>新生代GC的执行顺序如下：</p><ol><li>绝大多数新建的对象会存放在Eden空间。</li><li>Eden空间执行第一次Minor GC后，存活的对象被移动到其中一个survivor空间。</li><li>之后每次minor GC，都会将Eden和使用中的survivor区域中存活的对象，一次性复制到另一块空闲的survivor区，然后直接清理Eden与之前的survivor空间。</li><li>当空闲中的survivor空间不够存放活下来的对象时，这些对象会通过分配担保机制进入老年代。</li><li>以上步骤中重复N次（N &#x3D; MaxTenuringThreshold，默认为15）依然存活的对象会被移动到老年代。<br>以上步骤可知，两个survivor空间，必须有一个为空。简单总结便是，新创建的对象保存在Eden空间，经历多次GC仍然存活的对象会经由survivor空间转存到老年代空间。<br><em>一些占用大量连续内存的对象也会直接进入到老年代。</em><br>Java提供了<code>-XX:PretenureSizeThreshold</code>来指定对象内存大于该值（单位为字节）时直接分配到老年代。</li></ol><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>在新生代GC周期存活下来的对象会被拷贝到老年代区域，通常情况下该区域分配的空间要比新生代多，并且发生在老年代的GC次数也比新生代少得多（因为强分代假说）。<br>老年代的GC耗时会比新生代更长，因为老年代对象的内存占比更大，并且使用的是标记-清理算法，需要把存活对象排序整理为连续空间。</p><h2 id="方法区的GC"><a href="#方法区的GC" class="headerlink" title="方法区的GC"></a>方法区的GC</h2><p>该区域主要回收废弃的常量和类型，例如常量池里不会再被使用的各种符号引用等。类型信息的回收相对比较严苛：必须符合以下所有条件才会被回收：</p><ul><li>该类的所有对象实例被回收。</li><li>加载该类的ClassLoader被回收。</li><li>Class对象无法通过任何途径访问（包括反射）。<br>可以使用JVM参数中的<code>-Xnoclassgc</code>禁用方法区的回收。</li></ul><h2 id="常用的垃圾回收器"><a href="#常用的垃圾回收器" class="headerlink" title="常用的垃圾回收器"></a>常用的垃圾回收器</h2><p>每一个回收器在执行GC时都会使程序暂停一段时间，不同回收器的该暂停时间优化程度、算法不同。<br>目前引用最广的是JDK 8，默认使用的是Parallel Scavenge + Parallel Old 收集器组合。</p><h3 id="Serial-XX-UseSerialGC"><a href="#Serial-XX-UseSerialGC" class="headerlink" title="Serial (-XX:+UseSerialGC)"></a>Serial (-XX:+UseSerialGC)</h3><p>JVM初代垃圾回收器，负责收集新生代区域，采用标记-复制算法。在JDK 1.3之前是新生代区域的唯一选择，是一个单线程工作的收集器。仍是4核4G以下服务端的默认新生代收集器。没有线程交互开销，内存空间不大，单次回收耗时约几十毫秒。</p><h3 id="Serial-Old-XX-UseSerialOldGC"><a href="#Serial-Old-XX-UseSerialOldGC" class="headerlink" title="Serial Old (-XX:UseSerialOldGC)"></a>Serial Old (-XX:UseSerialOldGC)</h3><p>Serial Old是Serial收集器的老年代版本，同样也是单线程收集器，使用标记-整理算法，主要用于客户端模式下的HotSpot虚拟机使用。<br>如果在服务端模式下，它也有两种用途：一个是在JDK 5以及之前，和Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器在出现并发模式故障（Concurrent Mode Failure） 时作为后备收集器。</p><h3 id="ParNew-XX-UseParNewGC）"><a href="#ParNew-XX-UseParNewGC）" class="headerlink" title="ParNew (-XX:+UseParNewGC）"></a>ParNew (-XX:+UseParNewGC）</h3><p>随着计算机的核心数和内存容量都在飞速发展，多核心和大内存容量的场景下，Serial 收集器单线程的性能明显比较落后了，ParNew 就是 在Serial 收集器的基础之上，实现了它的多线程版本。它可以多条线程同时进行垃圾收集，这也是它和 Serial 收集器的最大的区别，其他的功能性、配置、策略等等的和 Serial 基本一致。<br>ParNew有一个比较重要的知识点，在JDK 9之后，Java官方取消了ParNew和除了CMS收集器之外的所有老年代收集器的搭配，而且还取消了 - XX:+UseParNewGC 这个参数。所以JDK 9之后，ParNew只能和CMS搭配使用了。</p><h3 id="Parallel-Scavenge-XX-UseParallelGC"><a href="#Parallel-Scavenge-XX-UseParallelGC" class="headerlink" title="Parallel Scavenge (-XX:+UseParallelGC)"></a>Parallel Scavenge (-XX:+UseParallelGC)</h3><p>与ParNew类似，都是新生代收集器，支持多线程并行回收，同样使用标记-复制算法。ParScav与ParNew关注点不同，它的目标是实现一个可控制吞吐量的GC。<br><em>吞吐量计算公式：运行用户代码时间 &#x2F; (运行用户代码时间 + 运行GC时间)</em><br>该GC提供了一些参数，允许用户按照需求控制吞吐量。</p><ul><li>-XX:MaxGCPauseMillis<br>  控制垃圾收集停顿的最大时间，单位是毫秒，可以设置一个大于0的数值。<br>不要想着把这个数值设置得很小来提升垃圾收集的速度，这里缩短的停顿时间是以牺牲新生代空间大小换来的，空间小，回收自然就快，停顿时间自然也短，但是空间小，吞吐量自然也会小。</li><li>-XX:GCTimeRatio<br>  设置垃圾收集时间占比的计算因子，参数范围是0 - 100的整数。它的公式是 1 &#x2F; (1+GCTimeRatio)<br>  举个栗子：当设置成15，那就是 1 &#x2F; (1+15) &#x3D; 0.0625，就是允许最大垃圾收集时间占总时间的6.25%，当设置成99的时候，就是 1 &#x2F; (1+99) &#x3D; 0.01，也就是允许最大垃圾收集时间占总时间的1%，依次类推。</li><li>-XX+UseAdaptiveSizePolicy<br>  当这个参数被激活，就不需要人工指定新生代的大小、Eden和Survivor区的比例、对象直接进入老年代的大小等等细节参数了，JVM会根据当前运行的情况动态调整，给出最合适的停顿时间和吞吐量。</li></ul><h3 id="Parallel-Old-XX-UseParallelOldGC"><a href="#Parallel-Old-XX-UseParallelOldGC" class="headerlink" title="Parallel Old (-XX:UseParallelOldGC)"></a>Parallel Old (-XX:UseParallelOldGC)</h3><p>是ParScav的老年代版本，同样自持多线程并行回收，在JDK 6时推出。在注重吞吐量与多核CPU情况下，豆科鱼优先考虑ParScav与Parallel Old收集器，这也是JDK 8默认的GC组合。</p><h3 id="CMS-XX-UseConcMarkSweepGC"><a href="#CMS-XX-UseConcMarkSweepGC" class="headerlink" title="CMS (-XX:+UseConcMarkSweepGC)"></a>CMS (-XX:+UseConcMarkSweepGC)</h3><p>CMS是JDK 1.4后推出的收集器，是一款并发低停顿的收集器，它负责收集老年代区域，采用标记-清除算法。对停顿时间低容忍的程序很适合使用CMS来GC。<br>它的运行过程可分为四个步骤：</p><ol><li>初始标记：该阶段需要暂停所有用户线程，但该结算速度很快，只需要标记与根节点直接关联的对象。</li><li>并发标记：该阶段不需要暂停用户线程。在初始标记完成后，从根节点直接关联的对象开始遍历整个引用链。该阶段耗时较长，但用户线程可与GC线程并发执行。</li><li>重新标记：该阶段需要暂停所有用户线程。并发标记阶段，用户线程与GC线程都在运行，相当于一边扫地一边丢垃圾，重新标记就是修正用户线程运行导致变动的一部分对象。该阶段耗时比初始标记长，但比并发标记短。该阶段可以多线程并行标记。</li><li>并发清理：该阶段不需要暂停用户线程。标记阶段完成后，此时便可遍历老年代空间，清理掉可回收对象，因为不需要移动整理存活对象，该阶段允许用户线程与GC线程并发执行。清理完成后会充值CMS收集器的数据结构，等待下一次GC.<br>CMS用两次较短的暂停时间来代替其他收集器一整段长暂停时间。<br>它也有一定缺点：</li></ol><ul><li>由于使用标记-清除算法，回收结束后会产生大量内存碎片。</li><li>GC进行时由于并发处理，会占用一部分计算资源，这个期间会降低一部分吞吐量（但也比之前几个好很多）。</li><li>由于CMS运行中有两个阶段是用户线程与GC线程并发执行，用户线程的继续执行会产生内存上的浮动垃圾，这些内存垃圾只能在下次触发GC时清除。为了处理这些浮动垃圾需要增大GC频率。JDK 5时，老年代空间使用了68%后就会触发一次GC， JDK 6时调整到了92%。<em>可以通过<code>-XX:CMSInitiatingOccupancyFraction</code>参数来调整这个阈值。</em></li></ul><h3 id="Garbage-First-G1"><a href="#Garbage-First-G1" class="headerlink" title="Garbage First (G1)"></a>Garbage First (G1)</h3><p>G1在JDK 8 Update 40时正式完成，在JDK 9时称为服务端模式下的默认GC.<br>G1的设计理念是实现一个停顿时间可控的低延迟GC.<br>G1依然遵守分代回收的设计理论，但它对堆不仅简单划分为新生代与老年代两个区域，而是划分为很多个大小相同的区域，新老年代也不再固定在特定区域，每一个区域都能根据运行所需，扮演Eden、Survivor、老年代区域或者Humongous区域。<br>大对象会被存储到Humongous区域，G1大多数情况会将该区域当作老年代看待。如果对象占用空间超过单一区域容量，则会存放到多个连续的Humongous区域中。<br>G1的运行流程可大致分为四个步骤：</p><ol><li>初始标记：暂停所有用户线程。只标记GC根节点直接关联的对象，还有一些额外操作，例如修改TAMS指针的值，保证后续阶段用户线程并发运行时，新对象分配在正确位置。</li><li>并发标记：不暂停用户线程。从根节点开始顺着引用链遍历整个堆，找出存活对象。</li><li>最终标记：暂停所有用户线程。处理并发标记时因用户线程运行产生的引用变动。支持并行处理。</li><li>筛选回收：暂停所有用户线程。根据三个阶段完成的标记数据计算出各个区域的回收加值与成本，再根据用户期望的停顿时间决定回收多少个区域。回收使用的是复制算法，将需要回收区域里存活的对象复制到空闲区域中，然后清理掉旧区域的全部空间。支持并行回收。<br><em>G1的停顿时间<code>-XX:MaxGCPauseMillis</code>的默认值是200 ms.</em></li></ol><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p>新生代中的对象有可能被老年代里的对象引用，当新生代触发GC时，明显不能只搜索新生代的区域，还得搜索老年代的对象是否引用了新生代中非GC根对象引用链上的对象，来确保GC正确。但这样做会带来很大的性能开销。<br>为了解决该问题，Java定义了一种名为记忆集的抽象数据结构，用于记录存在跨区域引用的对象指针集合。<br>大多数虚拟机都采用一种名为<strong>卡表</strong>的方式去实现记忆集。卡表由一个数组构成，每一个元素都对应一块特定大小的内存区域，这块内存区域被称为卡页。每一个卡页可能包含多个跨区域引用的对象，只要存在跨区域引用的对象，只要存在跨区域引用的对象，该卡页就会被标识为1。当GC开始时，不需要扫描整个区域，只需要被标记的卡页加入对应区域的根对象里一起扫描即可。</p><h3 id="新老晋升-分配担保机制"><a href="#新老晋升-分配担保机制" class="headerlink" title="新老晋升-分配担保机制"></a>新老晋升-分配担保机制</h3><p>当新生代的survivor空间中不足以存放所有存活对象时，存在新生代对象晋升至老年代的过程，此时老年代需要有足够空间来容纳这些对象。担保机制的流程如下：</p><ul><li>当新生代的Eden空间不足时会触发Minor GC，在Minor GC之前，JVM会检查老年代的剩余空间是否大于新生代中所有对象的总大小。</li><li>如果剩余空间足够，直接进行Minor GC.</li><li>如果剩余空间不足，JVM会查看<code>HandlePromotionFailure</code>参数设置:<ul><li>如果为真，JVM会进一步检查老年代的最大可用连续空间是否大于历次晋升到老年代的对象的平均大笑，如果大于，会尝试进行Minor GC，小于则改为进行Full GC.</li><li>如果为假，进行Full GC.</li></ul></li></ul><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java的对象：内存层面]]<br>[[Java的内存布局]]<br>[[内存回收算法]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/ff6a51426c0d/"/>
    <url>/2025-08-11/ff6a51426c0d/</url>
    
    <content type="html"><![CDATA[<p>Java中，静态类型（Static Type）是指变量在编译时生命的类型，它决定了变量可以存储的数据类型以及可以对变量执行的操作。<br>Java是一种静态类型语言，变量的类型必须在编译时明确声明，尽管Java对象的实际类型仍由运行时决定，但依然需要声明正确的类型用于编译时的类型检查，保证类型安全。声明类型也只用于编译检查。<br>如果将一个变量赋值给另一个类型不同的变量，必须进行显式的类型转换。<br>静态类型还决定了方法的重载行为。方法的参数类型和返回类型在编译时必须明确，让编译器能根据参数的静态类型选择合适的重载版本。</p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[JVM如何实现Java多态]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/ed991a2a6133/"/>
    <url>/2025-08-11/ed991a2a6133/</url>
    
    <content type="html"><![CDATA[<p>GC中最关键的部分则是用于判断哪些对象需要回收的标记算法。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数法通过为每个对象提供一个引用计数来标记可回收的对象。当对象被引用一次时，引用计数+1，当一个引用被释放时，计数-1。当引用计数为零时，表示没有任何引用指向该对象，该对象可以被回收内存。<br><strong>优点</strong> </p><ul><li>实时性能好：当一个对象没有引用时，该对象可以被立刻回收，释放内存资源。</li><li>简单高效：该算法在理解上相对高效简单。<br><strong>缺点</strong> </li><li>循环引用：当存在循环引用情况下，对象之间的引用计数可能永不为零，导致内存泄漏。</li><li>额外开销：每个对象都要维护一个引用技术及，会占据额外的内存空间。</li><li>不支持并发：该算法在多线程环境下需要额外的同步操作来保证计数准确性，可能导致一定性能损失。</li><li>实现繁琐：实现引用计数算法不算容易。<br>为了改进引用计数算法的循环引用问题，有两种主要方式进行改良。</li></ul><h3 id="延迟引用计数算法"><a href="#延迟引用计数算法" class="headerlink" title="延迟引用计数算法"></a>延迟引用计数算法</h3><p>此时的引用计数器不仅记录引用数量，还记录被引用对象可能的循环引用路径。<br><strong>工作原理</strong> </p><ul><li>每个对象都有一个引用计数器，记录指向该对象的引用数目。</li><li>引用计数的变化与原算法相同。</li><li>当引用计数器为零时，对象不会被立即释放，而是进入一个延迟释放队列。延迟释放队列会定期检查其中的对象是否存在循环引用。</li><li>如果发现循环引用，则将其从延迟释放队列中移除，保留对象引用。如果不存在，则对象最终会被释放。<br>该算法通过延迟释放对象，允许系统在一定时间内检测和解决循环引用问题。但同样不支持并发， 并且额外开销较大。</li></ul><h3 id="sticky引用计数算法"><a href="#sticky引用计数算法" class="headerlink" title="sticky引用计数算法"></a>sticky引用计数算法</h3><p>该算法通过引入<code>sticky</code>机制解决循环引用问题，让每个对象的引用计数部分多出一个sticky指示位。具体原理为：</p><ul><li>引用计数变化与原算法相同。</li><li>如果对象的引用计数器为零时，GC会检查其sticky指示位是否为真（是否为粘性引用）。</li><li>如果存在粘性引用，GC会进一步检查粘性引用是否有效，如果仍有效，则引用计数递增，否则回收该对象。<br>该方法同样是使用额外内存检查循环引用后额外处理，因此同样有内存开销大、不支持并发等问题。</li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>该算法的基本思路被称为根搜索算法，或标记-清除算法，是通过一系列成为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果每个对象到根对象之间没有任何引用链相连（即跟对象到该对象不可达），则证明该对象不可再被使用。<br>起始节点集可以包括在虚拟机栈（栈帧中的本地变量表）中引用的对象、再方法区中类静态属性引用的对象、在方法区中常量引用的对象、在本地方法栈中<code>Native</code>方法引用的对象等。<br>具体步骤如下：</p><ul><li>从根对象开始，将根对象标记为活动状态。</li><li>遍历根对下给你的引用，将所有被引用的对象也标记为活动状态。</li><li>迭代遍历被引用对象的引用，直到没有更多的对象被标记活动为止。</li><li>未被标记的对象即为不可达对象，可以被回收释放内存。<br><strong>优点</strong></li></ul><ul><li>简单高效：可达性分析算法使用了根搜索算法，具有简单高效的特点。</li><li>没有标记阶段开销：与其他垃圾回收算法不同，可达性分析算法没有显式的标记阶段，减少了回收时间和开销。<br><strong>缺点</strong></li><li>暂停应用程序：在执行垃圾回收时，可达性分析算法需要遍历对象引用关系图，导致应用程序的暂停。</li><li>空间效率低：可达性分析算法可能导致一些存活对象被错误地判定为不可达对象，从而导致内存泄漏。</li></ul><h2 id="分代垃圾收集算法"><a href="#分代垃圾收集算法" class="headerlink" title="分代垃圾收集算法"></a>分代垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说上：</p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的。</li><li>强分代假说：熬过越多次GC过程的对象就越难以消亡。<br>这两个分代假说共同奠定了多款常用垃圾收集器一致的设计原则：收集器应当将堆内存划分出不同区域，将回收对象基于其年龄（即熬过GC过程的次数）分配到不同区域中存储。<br>显而易见，当一个区域中大多数对象生命周期很短时，将它们集中在一处，每次回收时只关注如何保留少量存活对象而非标记需要被回收对象，就能以较低代价回收大量内存空间；如果剩下的都是难以消亡的对象，将它们集中在一块，虚拟机就能用较低的频率来回收该区域。这样就同时兼顾了GC的事件开销和内存空间的有效利用。<br>在堆内存被划分出不同区域后，GC才可以每次只回收某一个或某些部分的区域，因此产生了<code>Minor GC</code> 、<code>Major GC</code>、<code>Full GC</code>这样回收类型的区分，也才能针对不同的区域安排合适的GC算法——即“标记-复制算法”​“标记-清除算法”​“标记-整理算法”等针对性的GC算法。</li></ul><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最早出现也是最基础的GC算法，在1960年由John McCarthy所提出。算法分为标记与清除两个阶段：首先标记出所有需要回收的对象，然后统一回收这些对象占用的内存空间。<br>该算法有两个主要缺点：第一个是执行效率不稳定，如果堆内存中的大量对象都需要被回收，标记与清除的动作会重复多次，导致执行效率降低；第二个时清除对象后会产生大量不连续的内存碎片，导致以后程序运行需要分配较大内存时无法找到足够的连续内存，不得不提前执行另一次GC。</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决上述算法对大量可回收对象出现的效率低下问题，1969年Fenichel提出了一种称为“半区复制”(Semi-space Copying)的GC算法。其基本思想是将内存分为两块，每次只使用其中一块，当一块内存用完后，将仍存活的对象复制到另一块内存中，而原本的内存空间会被全部清理。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”(Mark-Compact)算法。该算法的标记过程与标记-清除算法一样，但后续步骤并非直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一侧移动，然后直接清理边界之外的内存。<br>但移动存活对象并更新所有引用地址同样开销巨大，并且这种移动操作必须全程暂停程序才能执行。</p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java 垃圾回收]]<br>[[Java的内存布局]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/9e18d219fc70/"/>
    <url>/2025-08-11/9e18d219fc70/</url>
    
    <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>JVM遇到一条字节码new指令时，首先会检查该指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否已经被加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。<br>类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后就能完全确定。<br>为对象分配内存实际上就是把一块确定大小的内存块从Java堆中划分出来。<br>如果堆内存是规整的，此时可使用指针方式分配内存，即指针碰撞。<br>如果内存不规整，使用过的与空闲的内存相互交错，此时会记录一个列表来记录那些内存块可用，即空闲列表分配。<br>Java堆内存是否规整，是由不同的垃圾回收器决定的。<br>内存分配完成后，虚拟机会将分配到的内存空间置零，并对对象进行必要设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码（这个实际上会延后到真正调用<code>Object::hasCode()</code>方法时计算）、对象的GC分代年龄等信息。这些信息存放在对象头之中。从虚拟机的角度，对象已经创建完成，不过在java程序的角度，还需要执行构造函数。</p><h1 id="线程安全的分配内存"><a href="#线程安全的分配内存" class="headerlink" title="线程安全的分配内存"></a>线程安全的分配内存</h1><p>为了保证在并发情况下，分配内存空间也有线程安全，Java有两种处理方式。<br>一是堆分配内存空间的工作进行同步处理，虚拟机上采用了CAS以及失败重试的方式来保证更新操作的原子性。<br><em>CAS(Compare-And-Swap)即比较并交换，是一种无锁的原子操作，用于多线程环境下实现同步机制，避免使用传统锁(synchronized关键字)，CAS 操作包含三个操作数：内存位置（V）、预期原值（A）和新值（B）。CAS 指令执行时，会先比较内存位置 V 处的值是否等于预期原值 A，如果相等，则将该位置的值更新为新值 B；如果不相等，则不做任何操作。它其实是一种乐观锁的方式，以 “假设无冲突” 为前提，通过无锁和重试机制实现原子操作。在java中的<code>AtomicInteger</code>、<code>CocurrentHashMap</code>（部分操作）、JVM内存分配都用到了它。</em><br>另一种方式是让每个线程在堆内存中预先分配一小块内存，成为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个本地缓冲区里分配，如果分配完了，再分配新的缓冲区时才需要同步锁定。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>HotSpot虚拟机中，对象在堆内存中可分为三部分：对象头，实例数据，内存对齐填充。</p><ul><li>对象头主要包括两种信息。一是存储对象自身运行时的数据，例如hash码、GC分代年龄、锁状态标志等。一是类型指针，即对象指向它类型元数据的指针，虚拟机通过该指针确定该对象是哪个类的实例。</li><li>实例数据部分是对象真正存储的有效信息，即代码中定义的各种类型字段的内容，包括父类继承下来的和子类中定义的。</li><li>对齐填充祈祷一个占位符的作用，HotSpot虚拟机的自动内存管理要求对象的起始地址必须是8字节的整数倍，如果数据部分没有对齐，就会产生对齐填充来补全。</li></ul><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序通过栈上的reference数据来操作堆上的具体对象。reference类型是一个指向对象的引用，它通过使用句柄或者直接指针来访问对象。<br><strong>句柄</strong><br>Java程序会在堆中划分一块内存作为句柄池&#x2F;句柄表，reference中存储的就是这个对象对应的句柄。<br>句柄表是一个数组，每个句柄都包含两个字段：对象的实际内存地址与对象的元数据地址，前者指向堆内存中的对象实例，后者指向对象的类元数据。<br>使用句柄来访问的最大好处是reference中存储的是稳定句柄地址，在对象被移动时（例如整理内存防止内存碎片）只会改变句柄中对象实例的地址，而reference本身（即句柄索引）和类元数据地址不会被修改。句柄法也可以更好的支持多线程环境，因为句柄表可以作为中间层提供更精确的锁控制，提高并发性能。<br><strong>直接指针</strong><br>使用该方式时，reference存储的就是对象的地址，省去一次间接访问的开销。使用直接指针的好处是访问速度更快。直接指针法也是多数现代JVM的默认方式。<br>reference变量中存储的地址实际上是指向对象头的地址。</p><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[Java的内存布局]]<br>[[对象初始化]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/558a4af5cf34/"/>
    <url>/2025-08-11/558a4af5cf34/</url>
    
    <content type="html"><![CDATA[<p>Java中的<code>HashMap</code>是一个基于哈希表实现的键值对存储结构。它提供了快速的插入、删除和查找操作，平均时间复杂度为O(1)。</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p><code>HashMap</code>的底层是一个数组（<code>Node&lt;K,V&gt;[] table</code>），每个数组元素称为一个桶。每个桶可以存储多个键值对，具体实现方式如下：</p><ul><li><strong>链表</strong>：当多个键映射到同一个桶时，这些键值对会以链表的形式存储在该桶中。</li><li><strong>红黑树</strong>：当链表的长度超过一个阈值（默认为8）时，链表会被转换为红黑树，以提高查找效率，时间复杂度会降低至O(log n)。<br>每一个键值对都储存在一个<code>Entry</code>（Java 8 及更高称为<code>Node</code>）类中。<code>Entry</code>是<code>HashMap</code>内部的一个用于表示就键值对的静态类，包含以下四个字段：</li><li>**<code>key</code>**：键对象。</li><li>**<code>value</code>**：值对象。</li><li>**<code>hash</code>**：键的哈希值，用于快速定位数组中的位置。</li><li>**<code>next</code>**：指向下一个<code>Entry</code>对象的引用，用于处理哈希冲突（链表结构）。<br>在Java 8及更高版本中，<code>Entry</code>被重命名为<code>Node</code>，并且引入了红黑树的实现。</li></ul><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当<code>HashMap</code>中的键值对数量超过一个阈值（<code>load factor * capacity</code>）时，会触发扩容操作。扩容过程包括：</p><ul><li>创建一个新的更大的数组（通常是原数组大小的两倍）。</li><li>将原数组中的所有键值对重新映射到新数组中。<br>扩容操作的时间复杂度为O(n)，但由于扩容操作不频繁，平均摊销复杂度仍然是O(1)。</li></ul><h3 id="线程安全？"><a href="#线程安全？" class="headerlink" title="线程安全？"></a>线程安全？</h3><p><code>HashMap</code>不是线程安全的。如果需要在多线程环境中使用，可以使用<code>ConcurrentHashMap</code>，或者通过外部同步机制（如<code>Collections.synchronizedMap</code>）来保证线程安全。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/7f099cbf2998/"/>
    <url>/2025-08-11/7f099cbf2998/</url>
    
    <content type="html"><![CDATA[<p>在Java I&#x2F;O体系中，流（Stream）分为字节流与字符流两大类。<br>字节流：以字节为单位处理数据，包括<code>InputStream</code>与<code>OutputStream</code>体系。<br>字符流：以字符为单位处理数据，包括<code>Reader</code>与<code>Writer</code>体系。</p><pre><code class=" mermaid">graph LRReader --&gt; CharArrayReaderReader --&gt; BufferedReaderBufferedReader --&gt; LineNumberReaderReader --&gt; PipedReaderReader --&gt; InputStreamReaderInputStreamReader --&gt; FileReaderReader --&gt; FilterReaderFilterReader --&gt; PushbackReaderReader --&gt; StringReader</code></pre><pre><code class=" mermaid">graph LRWriter --&gt; CharArrayWriterWriter --&gt; BUfferedWriterWriter --&gt; OutputStreamWriterOutputStreamWriter --&gt; FileReaderWriter --&gt; FilterWriterWriter --&gt; StringWriterWriter --&gt; PrintWriter</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/c40446f93688/"/>
    <url>/2025-08-11/c40446f93688/</url>
    
    <content type="html"><![CDATA[<p>Java中的异常主要分为两大类，<strong>受检查异常（Checked Exceptions）</strong> 和 <strong>非受检查异常（Unchecked Exceptions）</strong>，二者都继承自<code>java.lang.Throwable</code>。</p><h1 id="受检查异常"><a href="#受检查异常" class="headerlink" title="受检查异常"></a>受检查异常</h1><p>指在编译时必须被显式处理的异常。通常由于外部环境或者运行时条件导致，例如文件找不到、网络连接失败等。<br>受检查异常必须在方法的签名中声明（使用<code>throws</code>关键字），或者在方法内部用try-catch捕获。如果没有处理这些异常，编译器会报错。</p><h2 id="常见的受检查异常"><a href="#常见的受检查异常" class="headerlink" title="常见的受检查异常"></a>常见的受检查异常</h2><ul><li><code>IOException</code>（输入输出异常）</li><li><code>SQLException</code>（数据库操作异常）</li><li><code>ClassNotFoundException</code>（类找不到异常）</li></ul><h1 id="非受检查异常"><a href="#非受检查异常" class="headerlink" title="非受检查异常"></a>非受检查异常</h1><p>指在编译时不需要显式处理的异常。通常由于程序逻辑错误导致，例如空指针、数组越界等。<br>编译器不会强制要求处理这些异常，但是可以通过<code>try-catch</code>捕获处理。</p><h2 id="常见的非受检查异常"><a href="#常见的非受检查异常" class="headerlink" title="常见的非受检查异常"></a>常见的非受检查异常</h2><ul><li><code>NullPointerException</code>（空指针异常）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界异常）</li><li><code>ArithmeticException</code>（算术异常，例如除以零）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/322ce3a4d45b/"/>
    <url>/2025-08-11/322ce3a4d45b/</url>
    
    <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序时会把它管理的内存划分为若干不同的数据区域，主要包括以下几个，可按照线程所有权进行分类：<br><strong>线程私有：</strong> </p><ul><li>程序计数器</li><li>栈（虚拟机栈）</li><li>本地方法栈<br>**线程共享： </li><li>堆</li><li>方法区</li><li>直接内存（非运行时数据区的一部分）<br>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展。</li></ul><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器是一块较小的内存空间，用于记录当前线程执行到了什么位置。字节码解释器通过改变该计数器的值依次读取字节码指令，以实现代码的流程控制，例如分支、循环、跳转、异常处理、线程恢复等功能。<br>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的独立内存区域作为程序计数器。<br><em>程序计数器是唯一一个不会<code>OutOfMemoryError</code>的内存区域，其生命周期随线程同步创建和结束。</em></p><h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><p>堆内存是虚拟机管理的内存中最大的一块，在虚拟机启动时被创建。该内存的唯一目的就是存放对象实例，Java中几乎所有的对象实例都在此处分配内存。<br>堆也是GC管理的内存区域。堆可以处于物理上不连续的内存空间，但在逻辑上应当联系。</p><h1 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h1><p>与程序计数器相同，栈也是线程私有的，其生命周期也和线程同步创建和结束。<br>作为Java虚拟机运行时数据区域的一个核心，除了本地方法栈实现的Native方法，其他所有Java方法调用都是通过栈来实现。<br>方法调用的数据通过栈进行传递，每一次方法调用都有一个对应的栈帧压入栈中，调用结束后，都会有一个栈帧被弹出。<br>栈就是由一个个栈帧组成，每个栈帧中都有：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法返回地址<br><strong>局部变量表</strong> 主要存放编译期间可知的各种数据类型（boolean&#x2F;byte&#x2F;char&#x2F;short&#x2F;int&#x2F;float&#x2F;long&#x2F;double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是只想一个代表对象的句柄或于此对象有关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转，存放方法执行过程中产生的中间计算结果，计算过程中的临时变量也会放在该位置。<br><strong>动态链接</strong> 主要服务一个方法调用其他方法时的场景。<br>Class文件的常量池里保存了大量的符号引用（比如方法引用的符号引用）。当一个方法要调用其他方法，需要将常量池中只想方法的符号引用转化为其在内存地址中的直接引用。该过程就叫做动态链接。<br>当函数调用陷入无限循环时，会导致栈中被压入太多栈帧占用太多空间，导致栈空间过深。当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，就会抛出<code>StackOverflow</code>错误。<br>Java方法无论是通过return语句正常返回，还是抛出异常后返回，都会导致栈帧被弹出，即栈帧的生命周期随方法的调用而创建，随方法结束被销毁。</li></ul><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>属于Java虚拟机运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。在不同的虚拟机上，方法区的实现不同。方法区会存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong><br>当虚拟机使用一个类时，它需要读取并解析class文件获取相关信息，再将信息存入方法区。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈与栈内存作用相似，区别仅为栈为虚拟机执行Java方法（即字节码）服务，本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈一样会在深度溢出或者栈扩展失败时抛出对应异常。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>属于方法区的一部分。class文件还包含一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容会在类加载后存放到方法区的运行时常量池中。<br>Java不要求常量一定只有编译期才能产生，也就是说，不仅仅是class文件常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中。例如String类的<code>intern()</code>方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/3373a1e49ec7/"/>
    <url>/2025-08-11/3373a1e49ec7/</url>
    
    <content type="html"><![CDATA[<p>Java 8之前，在实现接口或继承类时，需要显式声明类名、方法名等，代码较为冗长，缺乏简洁的函数式接口支持。因此Java通过匿名内部类与Lambda表达式来解决该问题，即支持<strong>函数式编程</strong>。除此之外，二者还可用于代码简化、封装局部逻辑，实现事件处理器与回调函数。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据结构与可变状态。<br>Lambda表达式提供了一种简洁的方式来实现单方法接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用匿名内部类</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用lambda表达式</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runaable2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="简化代码与局部逻辑封装"><a href="#简化代码与局部逻辑封装" class="headerlink" title="简化代码与局部逻辑封装"></a>简化代码与局部逻辑封装</h2><p>匿名内部类与lambda表达式的主要目标之一就是简化代码，提高可读性，减轻维护难度。<br>lambda表达式能省略类名与方法名直接实现接口的唯一方法，使代码简洁。<br>使用方法引用可以进一步简化lambda表达式，直接引用已有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匿名内部类</span><br>Comparator&lt;String&gt; comparator1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br><span class="hljs-keyword">return</span> s1.length() - s2.length();<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// lambda表达式</span><br>COmparator&lt;String&gt; comparator2 = (s1, s2) -&gt; s1.length() - s2.length();<br><br><span class="hljs-comment">// 方法引用</span><br>Comparator&lt;String&gt; comparator3 = Comparator.comparingInt(String::length);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br><span class="hljs-comment">// 使用匿名内部类封装逻辑</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Output:&quot;</span> + output);<br>&#125;<br>&#125;).start();<br><br><span class="hljs-comment">// 使用lambda表达式</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;System.out.println(<span class="hljs-string">&quot;Output&quot;</span> + output)).start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件回调"><a href="#事件回调" class="headerlink" title="事件回调"></a>事件回调</h2><p>lambda表达式与匿名内部类也常用于事件处理与异步操作中的回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匿名内部类</span><br>button.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionLisener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Get Clicked&quot;</span>);<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// lambda表达式</span><br>button.addActionListener(e -&gt; System.out.println(<span class="hljs-string">&quot;Get Clicked&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="封装多个函数"><a href="#封装多个函数" class="headerlink" title="封装多个函数"></a>封装多个函数</h2><p>显然内部类与lambda表达式都支持包裹多语句，但在实现多个接口时，匿名内部类会更加好，因其可以实现接口或继承类且可以包含多个方法；而lambda表达式本就用于表示一个方法的实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要实现的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">I_new</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用匿名内部类实现则很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">I_new</span> <span class="hljs-variable">myInterface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">I_new</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123; sout(<span class="hljs-string">&quot;Hello&quot;</span>); &#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123; sout(<span class="hljs-string">&quot;Hi&quot;</span>); &#125;<br>&#125;;<br><br>myInterface.method1();<br>myInterface.method2();<br></code></pre></td></tr></table></figure><p>强行用lambda表达式的话，则需要用一个类组合该方法，再初始化这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Method1</span>() &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>; &#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Method2</span>() &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinedMethods</span> &#123;<br>    <span class="hljs-keyword">private</span> Method1 method1;<br>    <span class="hljs-keyword">private</span> Method2 method2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CombinedMethods</span><span class="hljs-params">(Method1 method1, Method2 method2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.method1 = method1;<br>        <span class="hljs-built_in">this</span>.method2 = method2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeMethod1</span><span class="hljs-params">()</span> &#123;<br>        method1.execute();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeMethod2</span><span class="hljs-params">()</span> &#123;<br>        method2.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/e2143ca0e3b5/"/>
    <url>/2025-08-11/e2143ca0e3b5/</url>
    
    <content type="html"><![CDATA[<ul><li>继承了父类的对象在初始化时，会先调用父类的构造函数</li><li>在调用一个类的构造函数之前，会先初始化该类中的成员变量</li><li>如果子类中存在与父类同名的成员变量，则子类成员变量会将父类的隐藏；如果需要访问父类同名变量，则可使用super.变量名访问<br>一个对象的初始化过程：</li></ul><ol><li>初始化父类的静态成员变量与静态代码块；</li><li>初始化子类的静态成员变量与静态代码块；</li><li>初始化父类的普通成员变量和代码块，然后执行父类构造函数；</li><li>初始化子类的普通成员变量和代码块，然后执行子类构造函数。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025-08-11/dea1438b9ccc/"/>
    <url>/2025-08-11/dea1438b9ccc/</url>
    
    <content type="html"><![CDATA[<p>抽象类的主要目的是提供一个通用的类模板，允许子类继承并视线一些通用行为，同时也可以强制子类实现某些特定方法。<br>抽象类无法直接实例化，而是作为其他类的基类使用。<br>抽象类可以包含普通方法和成员变量，用于提供默认的视线，供子类继承&#x2F;使用；子类可以选择重写这些非抽象方法。<br>抽象类可以不包含抽象方法。<br>抽象方法必须位于抽象类内，即如果一个类包含方法， 那么这个类必须声明为抽象类。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统构建</title>
    <link href="/2025-07-29/d652fa742b62/"/>
    <url>/2025-07-29/d652fa742b62/</url>
    
    <content type="html"><![CDATA[<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>基础的分布式调用框架包含<strong>服务注册中心</strong>、<strong>服务提供者</strong>、<strong>服务消费者</strong>，支持：</p><ul><li>服务注册与发现（服务地址的动态管理）</li><li>远程通信（基于TCP的自定义协议）</li><li>简单的负载均衡（轮询策略）</li></ul><h1 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h1><ul><li>网络通信：使用Java NIO（非阻塞IO）实现TCP通信</li><li>序列化：自定义将Java对象转为字节流</li><li>服务注册：基于内存存储服务地址（在生产环境可用ZooKeeper&#x2F;Redis）</li><li>远程调用：模拟RPC（远程过程调用）流程</li></ul><h1 id="分布实现"><a href="#分布实现" class="headerlink" title="分布实现"></a>分布实现</h1><h2 id="定义通信协议"><a href="#定义通信协议" class="headerlink" title="定义通信协议"></a>定义通信协议</h2><p>让服务之间能正确解析信息，定义如下的简单协议格式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">MessageLength</span>(<span class="hljs-name">4byte</span>)][<span class="hljs-name">MessageType</span>(<span class="hljs-name">1byte</span>)][<span class="hljs-name">MessageInfo</span>(<span class="hljs-name">byte</span>[])]<br></code></pre></td></tr></table></figure><p>消息长度：int类型，表示后续内容总长<br>消息类型：0&#x3D;请求，1&#x3D;响应<br>消息内容：序列化后的请求&#x2F;响应数据</p><h2 id="实现序列化工具（简单对象转字节）"><a href="#实现序列化工具（简单对象转字节）" class="headerlink" title="实现序列化工具（简单对象转字节）"></a>实现序列化工具（简单对象转字节）</h2><p>生产环境中可使用Protobuf&#x2F;Hessian来实现对象序列化。</p><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><p>服务注册中心负责接受服务提供者的注册信息，并向消费者提供服务地址列表。</p><h2 id="远程通信框架"><a href="#远程通信框架" class="headerlink" title="远程通信框架"></a>远程通信框架</h2><p>使用Java NIO的Selector实现非阻塞通信，处理服务之间的请求和响应。</p><h1 id="进阶优化方向"><a href="#进阶优化方向" class="headerlink" title="进阶优化方向"></a>进阶优化方向</h1><h2 id="服务健康检查"><a href="#服务健康检查" class="headerlink" title="服务健康检查"></a>服务健康检查</h2><p>定期检测服务是否可用，自动提出故障节点。</p><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>实现重试、超时控制、熔断逻辑。</p><h2 id="更高效的序列化"><a href="#更高效的序列化" class="headerlink" title="更高效的序列化"></a>更高效的序列化</h2><p>替换Java的默认序列化，使用Protobuf以提升性能。</p><h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>引入Zookeeper实现注册中心高可用。</p><h2 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h2><p>使用Netty替代NIO，支持异步非阻塞调用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络报文发送流程</title>
    <link href="/2025-07-08/6e8a6f975120/"/>
    <url>/2025-07-08/6e8a6f975120/</url>
    
    <content type="html"><![CDATA[<p>下面以 “用户通过浏览器发送请求到服务器” 为例，详细讲解 TCP&#x2F;IP 协议发送报文的完整流程：</p><h3 id="一、TCP-IP-协议栈的层次结构"><a href="#一、TCP-IP-协议栈的层次结构" class="headerlink" title="一、TCP&#x2F;IP 协议栈的层次结构"></a><strong>一、TCP&#x2F;IP 协议栈的层次结构</strong></h3><p>TCP&#x2F;IP 协议栈分为 4 层（或 5 层，此处以 4 层为例），发送报文时遵循 “自上而下封装” 原则，每层会添加本层的<strong>头部信息</strong>（类似 “信封”），最终形成可在网络中传输的 “帧”。<br>4 层结构及功能如下：</p><table><thead><tr><th>层次</th><th>核心功能</th><th>代表性协议</th><th>封装的头部信息</th></tr></thead><tbody><tr><td>应用层</td><td>处理用户数据（如 HTTP 请求、邮件）</td><td>HTTP、FTP、SMTP、DNS</td><td>应用层头部（如 HTTP 的请求方法、URL）</td></tr><tr><td>传输层</td><td>确保数据可靠传输（或快速传输）</td><td>TCP（可靠）、UDP（快速）</td><td>源端口、目的端口、序号（TCP 特有）</td></tr><tr><td>网络层</td><td>负责跨网络路由（选择传输路径）</td><td>IP</td><td>源 IP 地址、目的 IP 地址、协议类型</td></tr><tr><td>数据链路层</td><td>负责局域网内数据传输（相邻设备）</td><td>Ethernet（以太网）</td><td>源 MAC 地址、目的 MAC 地址、帧校验码</td></tr></tbody></table><h3 id="二、发送报文的详细流程（封装过程）"><a href="#二、发送报文的详细流程（封装过程）" class="headerlink" title="二、发送报文的详细流程（封装过程）"></a><strong>二、发送报文的详细流程（封装过程）</strong></h3><p>假设用户在浏览器输入<code>www.example.com</code>并发送请求，报文发送步骤如下：</p><h4 id="1-应用层：生成原始数据并添加应用层头部"><a href="#1-应用层：生成原始数据并添加应用层头部" class="headerlink" title="1. 应用层：生成原始数据并添加应用层头部"></a><strong>1. 应用层：生成原始数据并添加应用层头部</strong></h4><ul><li><strong>数据来源</strong>：应用程序（如浏览器）生成原始数据，例如 HTTP 请求（包含请求方法<code>GET</code>、目标 URL、请求头<code>Host: www.example.com</code>等）。</li><li><strong>封装操作</strong>：应用层协议（如 HTTP）会给原始数据添加<strong>应用层头部</strong>（Header），形成 “应用层报文”。<ul><li>例如：HTTP 头部会包含<code>User-Agent</code>（浏览器类型）、<code>Content-Length</code>（数据长度）等信息，用于告知服务器 “如何解析数据”。</li></ul></li></ul><h4 id="2-传输层：添加传输层头部（TCP-或-UDP）"><a href="#2-传输层：添加传输层头部（TCP-或-UDP）" class="headerlink" title="2. 传输层：添加传输层头部（TCP 或 UDP）"></a><strong>2. 传输层：添加传输层头部（TCP 或 UDP）</strong></h4><ul><li><strong>协议选择</strong>：若需可靠传输（如 HTTP、文件传输），使用 TCP；若需快速传输（如视频、语音），使用 UDP。此处以 TCP 为例。</li><li><strong>封装操作</strong>：传输层将应用层报文作为 “数据部分”，添加<strong>TCP 头部</strong>，形成 “TCP 报文段”。<ul><li>TCP 头部关键信息：<ul><li><strong>源端口</strong>：客户端的端口（如浏览器随机分配的临时端口，如<code>54321</code>）；</li><li><strong>目的端口</strong>：服务器的端口（如 HTTP 默认<code>80</code>，HTTPS 默认<code>443</code>）；</li><li><strong>序号</strong>：TCP 是 “面向字节流” 的协议，序号用于标记数据顺序，确保接收端能按顺序重组；</li><li><strong>确认号</strong>：用于确认已收到的数据（仅在响应中使用）；</li><li><strong>标志位</strong>：如<code>SYN</code>（建立连接）、<code>ACK</code>（确认）、<code>FIN</code>（断开连接）等，控制连接状态。</li></ul></li></ul></li></ul><h4 id="3-网络层：添加-IP-头部（跨网络传输的核心）"><a href="#3-网络层：添加-IP-头部（跨网络传输的核心）" class="headerlink" title="3. 网络层：添加 IP 头部（跨网络传输的核心）"></a><strong>3. 网络层：添加 IP 头部（跨网络传输的核心）</strong></h4><ul><li><strong>核心功能</strong>：网络层通过 IP 协议将 TCP 报文段封装为 “IP 数据报”，并通过<strong>IP 地址</strong>确定传输路径（路由选择）。</li><li><strong>封装操作</strong>：网络层将 TCP 报文段作为 “数据部分”，添加<strong>IP 头部</strong>，形成 “IP 数据报”。<ul><li>IP 头部关键信息：<ul><li><strong>源 IP 地址</strong>：发送端的 IP（如客户端<code>192.168.1.100</code>）；</li><li><strong>目的 IP 地址</strong>：接收端的 IP（如服务器<code>203.0.113.5</code>）；</li><li><strong>协议字段</strong>：标记上层协议（如<code>6</code>代表 TCP，<code>17</code>代表 UDP），告知接收端该交给传输层的哪个协议处理；</li><li><strong>TTL（生存时间）</strong>：防止数据报在网络中无限循环（每经过一个路由器减 1，为 0 则丢弃）。</li></ul></li></ul></li></ul><h4 id="4-数据链路层：添加-MAC-头部（局域网内传输）"><a href="#4-数据链路层：添加-MAC-头部（局域网内传输）" class="headerlink" title="4. 数据链路层：添加 MAC 头部（局域网内传输）"></a><strong>4. 数据链路层：添加 MAC 头部（局域网内传输）</strong></h4><ul><li><strong>核心功能</strong>：数据链路层通过<strong>MAC 地址</strong>（硬件地址，如网卡物理地址）在局域网内传输数据，将 IP 数据报封装为 “帧”。</li><li><strong>封装操作</strong>：数据链路层将 IP 数据报作为 “数据部分”，添加<strong>MAC 头部</strong>和<strong>帧尾</strong>（校验码），形成 “帧”。<ul><li>MAC 头部关键信息：<ul><li><strong>源 MAC 地址</strong>：发送端设备的网卡地址（如客户端电脑的 MAC）；</li><li><strong>目的 MAC 地址</strong>：局域网内下一跳设备的 MAC（如路由器的 MAC，而非最终服务器的 MAC，因为跨网络传输需通过路由器转发）。</li></ul></li></ul></li></ul><h4 id="5-物理层：将帧转换为电信号-光信号传输"><a href="#5-物理层：将帧转换为电信号-光信号传输" class="headerlink" title="5. 物理层：将帧转换为电信号 &#x2F; 光信号传输"></a><strong>5. 物理层：将帧转换为电信号 &#x2F; 光信号传输</strong></h4><p>物理层（如网线、光纤、无线信号）将数据链路层的 “帧” 转换为物理信号（如电脉冲、光脉冲），通过传输介质发送到下一个设备（如路由器、交换机）。</p><h3 id="三、关键补充：路由转发中的-“MAC-地址动态更新”"><a href="#三、关键补充：路由转发中的-“MAC-地址动态更新”" class="headerlink" title="三、关键补充：路由转发中的 “MAC 地址动态更新”"></a><strong>三、关键补充：路由转发中的 “MAC 地址动态更新”</strong></h3><p>当报文需要跨多个网络（如从家庭 WiFi 到运营商网络，再到服务器所在网络）时，<strong>IP 地址不变</strong>（始终是源 IP 和目的 IP），但<strong>MAC 地址会逐跳更新</strong>：</p><ul><li>客户端→路由器 1：MAC 目的地址是路由器 1 的 MAC；</li><li>路由器 1→路由器 2：MAC 目的地址是路由器 2 的 MAC；</li><li>最后一跳路由器→服务器：MAC 目的地址是服务器的 MAC。<br>这是因为 MAC 地址仅在局域网内有效，而 IP 地址负责跨网络定位最终目标。</li></ul><h3 id="四、总结：发送报文的核心逻辑"><a href="#四、总结：发送报文的核心逻辑" class="headerlink" title="四、总结：发送报文的核心逻辑"></a><strong>四、总结：发送报文的核心逻辑</strong></h3><ol><li><strong>封装</strong>：每层添加头部信息，从应用层的 “纯数据” 逐步包装为物理层的 “信号”；</li><li><strong>地址定位</strong>：IP 地址确定 “终点”，MAC 地址确定 “当前跳的下一站”；</li><li><strong>分工协作</strong>：应用层处理用户需求，传输层确保可靠性，网络层负责路由，数据链路层负责局域网传输，物理层负责信号转换。<br>接收端收到报文后，会从物理层到应用层逐层 “解封装”（剥离头部），最终将数据交给目标应用程序（如服务器的 HTTP 服务）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目功能模块概览</title>
    <link href="/2025-07-02/f60e918d4783/"/>
    <url>/2025-07-02/f60e918d4783/</url>
    
    <content type="html"><![CDATA[<h1 id="后台管理系统"><a href="#后台管理系统" class="headerlink" title="后台管理系统"></a>后台管理系统</h1><p>主要分为商品模块、订单模块、营销模块和权限模块。</p><ul><li>商品模块包括：商品管理、商品分类管理、商品类型管理、品牌管理</li><li>订单模块包括：订单管理、订单设置、退货申请处理、退货原因设置</li><li>营销模块包括：秒杀活动管理、优惠券管理、品牌推荐管理、新品推荐管理、人气推荐管理、专题推荐管理、首页广告管理</li><li>权限模块包括：用户管理、菜单管理、角色管理、资源管理</li></ul><h1 id="数据库表前缀说明"><a href="#数据库表前缀说明" class="headerlink" title="数据库表前缀说明"></a>数据库表前缀说明</h1><ul><li>pms_*：商品模块相关表</li><li>oms_*：订单模块相关表</li><li>sms_*：营销模块相关表</li><li>ums_*：权限模块相关表</li><li>cms_*：内容模块相关表</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目系统架构</title>
    <link href="/2025-07-02/97e3a71ab2f4/"/>
    <url>/2025-07-02/97e3a71ab2f4/</url>
    
    <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><ol><li>前端服务<ul><li>后台管理系统（Vue）</li><li>前台商城系统（uni-app）</li></ul></li><li>网关服务（Nginx）</li><li>后端服务（SpringBoot）</li><li>数据存储<ul><li>主要业务数据存储（MySql）</li><li>缓存数据存储（Redis）</li><li>用户行为分析数据存储（MongoDB）</li><li>搜索数据存储（Elastic search）</li></ul></li><li>日志收集<ul><li>Kibana</li><li>Elasticsearch</li><li>Logstash</li></ul></li><li>异步通信&#x2F;消息队列（RabbitMQ）</li><li>文件存储&#x2F;对象存储（OSS&#x2F;MiniO）</li><li>容器化部署（Docker）</li><li>持续集成&#x2F;自动化部署（Jenkins）<br>![[mall项目系统架构图.jpg]]</li></ol><h1 id="项目使用技术"><a href="#项目使用技术" class="headerlink" title="项目使用技术"></a>项目使用技术</h1><h2 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h2><table><thead><tr><th>技术</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.7.5</td><td>容器+MVC框架</td></tr><tr><td>SpringSecurity</td><td>5.7.4</td><td>认证和授权框架</td></tr><tr><td>MyBatis</td><td>3.5.10</td><td>ORM框架</td></tr><tr><td>MyBatisGenerator</td><td>1.4.1</td><td>数据层代码生成</td></tr><tr><td>RabbitMQ</td><td>3.10.5</td><td>消息队列</td></tr><tr><td>Redis</td><td>7.0</td><td>分布式缓存</td></tr><tr><td>MongoDB</td><td>5.0</td><td>NoSql数据库</td></tr><tr><td>Elasticsearch</td><td>7.17.3</td><td>搜索引擎</td></tr><tr><td>LogStash</td><td>7.17.3</td><td>日志收集工具</td></tr><tr><td>Kibana</td><td>7.17.3</td><td>日志可视化查看工具</td></tr><tr><td>Nginx</td><td>1.22</td><td>静态资源服务器</td></tr><tr><td>Druid</td><td>1.2.14</td><td>数据库连接池</td></tr><tr><td>MinIO</td><td>8.4.5</td><td>对象存储</td></tr><tr><td>Hutool</td><td>5.8.0</td><td>Java工具类库</td></tr><tr><td>PageHelper</td><td>5.3.2</td><td>MyBatis物理分页插件</td></tr><tr><td>Swagger-UI</td><td>3.0.0</td><td>文档生成工具</td></tr><tr><td>logstash-logback-encoder</td><td>7.2</td><td>Logstash日志收集插件</td></tr><tr><td>docker-maven-plugin</td><td>0.40.2</td><td>应用打包成Docker镜像的Maven插件</td></tr></tbody></table><h2 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h2><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Vue</td><td>前端框架</td></tr><tr><td>Vue-router</td><td>路由框架</td></tr><tr><td>Vuex</td><td>全局状态管理框架</td></tr><tr><td>Element</td><td>前端UI框架</td></tr><tr><td>Axios</td><td>前端HTTP框架</td></tr><tr><td>v-charts</td><td>基于Echarts的图表框架</td></tr><tr><td>Js-cookie</td><td>cookie管理工具</td></tr><tr><td>nprogress</td><td>进度条控件</td></tr><tr><td>vue-element-admin</td><td>项目脚手架参考</td></tr></tbody></table><h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Vue</td><td>核心前端框架</td></tr><tr><td>Vuex</td><td>全局状态管理框架</td></tr><tr><td>uni-app</td><td>移动端前端框架</td></tr><tr><td>mix-mall</td><td>电商项目模板</td></tr><tr><td>luch-request</td><td>HTTP请求框架</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库 索引</title>
    <link href="/2025-06-30/06469df58728/"/>
    <url>/2025-06-30/06469df58728/</url>
    
    <content type="html"><![CDATA[<p>数据库系统中，索引是提升查询效率的核心机制。索引是<strong>数据库中依附于表的一种特殊数据结构</strong>，它基于表中的某一列或多列组合（称为索引键）构建，通过在底层对索引键的值进行有序存储，形成一个快速查找的映射（即索引键值与对应数据在表中的物理&#x2F;逻辑位置），来提高查找效率。<br>索引不存储完整数据，只存储索引键值和数据的位置信息，占用空间远小于表本身。<br>索引可以简单理解为：表内的数据是一本书的正文，索引是带页码的目录。</p><h1 id="索引解决了什么"><a href="#索引解决了什么" class="headerlink" title="索引解决了什么"></a>索引解决了什么</h1><p>索引的设计是为了解决<strong>数据量巨大时查询效率低下</strong>的问题，加速数据访问，主要分为两部分：<br><strong>避免全表扫描的低效操作</strong><br>当表中数据量庞大（如百万、千万级）时，若没有索引，查询语句（如<code>WHERE age = 30</code>）需要逐行检查所有数据（全表扫描），时间复杂度为<code>O(n)</code>，耗时极长。<br>索引通过预先对索引键排序，可将查询时间复杂度降至<code>O(log n)</code>（如 B 树索引），大幅缩短查询耗时。<br><strong>平衡查询和写入的性能</strong><br>索引并非单纯为了 “快”，而是在 “查询速度” 和 “写入（INSERT&#x2F;UPDATE&#x2F;DELETE）成本” 之间找平衡：</p><ul><li>无索引时，写入快（无需维护索引）但查询慢</li><li>索引过多时，查询快但写入慢（需同步更新所有索引）<br>因此索引的设计目标是：让 “高频查询” 足够快，同时让 “写入成本” 可控。</li></ul><h1 id="索引的应用场景"><a href="#索引的应用场景" class="headerlink" title="索引的应用场景"></a>索引的应用场景</h1><h4 id="1-加速各类查询操作"><a href="#1-加速各类查询操作" class="headerlink" title="1. 加速各类查询操作"></a>1. 加速各类查询操作</h4><ul><li><strong>单表等值查询</strong>：如<code>WHERE id = 100</code>（主键索引）、<code>WHERE phone = &#39;138xxxx&#39;</code>（普通索引），直接通过索引定位数据位置。</li><li><strong>范围查询</strong>：如<code>WHERE age BETWEEN 20 AND 30</code>，基于索引的有序性，可快速锁定范围边界，无需全表扫描。</li><li><strong>排序与分组</strong>：如<code>ORDER BY create_time</code>、<code>GROUP BY department</code>，若索引键与排序 &#x2F; 分组字段一致，数据库可直接利用索引的有序性完成操作，避免额外排序（称为 “索引排序”）。</li><li><strong>连接查询</strong>：如<code>JOIN user ON order.user_id = user.id</code>，若<code>order.user_id</code>和<code>user.id</code>有索引，可快速匹配关联数据，减少连接耗时。</li></ul><h4 id="2-维护数据完整性"><a href="#2-维护数据完整性" class="headerlink" title="2. 维护数据完整性"></a>2. 维护数据完整性</h4><ul><li>唯一索引（UNIQUE INDEX）通过强制索引键值不重复，可保障数据唯一性（如手机号、邮箱不能重复），替代部分业务层的校验逻辑。</li><li>主键索引（PRIMARY KEY）不仅加速查询，还通过 “非空 + 唯一” 约束确保表中每行数据有唯一标识，是表结构的基础。</li></ul><h4 id="3-局限性（不能做到的事）"><a href="#3-局限性（不能做到的事）" class="headerlink" title="3. 局限性（不能做到的事）"></a>3. 局限性（不能做到的事）</h4><ul><li>对 “模糊查询前缀不固定”（如<code>WHERE name LIKE &#39;%张%&#39;</code>）无效，因为索引依赖有序性，前缀模糊会导致无法定位。</li><li>拖延写入操作：写入时需同步更新索引结构（如 B 树的插入 &#x2F; 调整），索引越多，写入越慢。</li><li>小表（如几百行数据）中作用有限：全表扫描耗时极短，索引的维护成本可能超过查询收益。</li></ul><h1 id="索引的底层实现"><a href="#索引的底层实现" class="headerlink" title="索引的底层实现"></a>索引的底层实现</h1><p>索引的底层实现由数据库的存储引擎（如 MySQL 的 InnoDB、PostgreSQL 的 B-tree 索引）决定，不同数据结构适用于不同场景。以下是最常用的几种：</p><h4 id="1-B-树与-B-树索引（最主流）"><a href="#1-B-树与-B-树索引（最主流）" class="headerlink" title="1. B 树与 B + 树索引（最主流）"></a>1. B 树与 B + 树索引（最主流）</h4><ul><li><strong>结构</strong>：<ul><li>B 树是一种 “多路平衡查找树”，每个节点存储 “索引键值 + 数据指针”，且节点中的键值有序排列；</li><li>B + 树是 B 树的优化版：非叶子节点仅存索引键（不存数据指针），所有数据指针集中在叶子节点，且叶子节点通过链表相连（形成有序链表）。</li></ul></li><li><strong>优势</strong>：<ul><li>有序性支持 “范围查询”（如<code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>）：叶子节点的链表结构可快速遍历连续范围。</li><li>平衡性：树的高度低（通常 3-4 层），即使数据量千万级，也只需 3-4 次磁盘 IO 即可定位数据。</li><li>适配磁盘存储：节点大小通常与磁盘块（如 4KB）一致，减少 IO 次数（磁盘 IO 是数据库性能瓶颈）。</li></ul></li><li><strong>适用场景</strong>：绝大多数关系型数据库的默认索引（如 MySQL InnoDB 的主键索引、普通索引均为 B + 树），支持等值查询、范围查询、排序等。</li></ul><h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h4><ul><li><strong>结构</strong>：基于哈希表实现，通过哈希函数将索引键值映射为哈希码，哈希码对应数据的存储位置。</li><li><strong>优势</strong>：等值查询（<code>=</code>）速度极快，时间复杂度接近<code>O(1)</code>（直接通过哈希码定位）。</li><li><strong>局限性</strong>：<ul><li>不支持范围查询（哈希码无序）、排序（哈希码无顺序关系）。</li><li>存在哈希冲突（不同键值映射到同一哈希码），需额外处理（如链表法）。</li></ul></li><li><strong>适用场景</strong>：仅支持等值查询的场景，如 MySQL 的 Memory 引擎（内存表）默认使用哈希索引。</li></ul><h4 id="3-R-树索引"><a href="#3-R-树索引" class="headerlink" title="3. R 树索引"></a>3. R 树索引</h4><ul><li><strong>结构</strong>：专为 “空间数据” 设计的树形结构，索引键是空间对象（如点、矩形、多边形），节点存储 “最小边界矩形（MBR）”，通过 MBR 快速过滤不相关数据。</li><li><strong>优势</strong>：高效处理空间查询，如 “查询某区域内的所有店铺”（地理信息系统 GIS 常用）。</li><li><strong>适用场景</strong>：PostgreSQL 的 PostGIS 扩展、MySQL 的空间索引，支持<code>ST_Contains</code>等空间函数。</li></ul><h4 id="4-聚簇索引-vs-非聚簇索引（按数据存储方式分类）"><a href="#4-聚簇索引-vs-非聚簇索引（按数据存储方式分类）" class="headerlink" title="4. 聚簇索引 vs 非聚簇索引（按数据存储方式分类）"></a>4. 聚簇索引 vs 非聚簇索引（按数据存储方式分类）</h4><ul><li><strong>聚簇索引（Clustered Index）</strong>：<ul><li>数据行的物理存储顺序与索引键的逻辑顺序一致（即 “索引即数据”）。</li><li>一张表只能有一个聚簇索引（因为物理存储顺序唯一）。</li><li>例子：MySQL InnoDB 的主键索引是聚簇索引，叶子节点直接存储整行数据，查询主键时无需二次查找。</li></ul></li><li><strong>非聚簇索引（Non-Clustered Index）</strong>：<ul><li>索引与数据分开存储，索引的叶子节点存储 “索引键值 + 聚簇索引键（如主键）”，查询时需先查非聚簇索引得到主键，再通过聚簇索引查完整数据（称为 “回表”）。</li><li>一张表可有多非聚簇索引（不影响数据物理存储）。</li><li>例子：MySQL InnoDB 的普通索引（如<code>phone</code>列的索引）是非聚簇索引。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>双端实现及通信规则</title>
    <link href="/2025-06-20/28b7046a4d27/"/>
    <url>/2025-06-20/28b7046a4d27/</url>
    
    <content type="html"><![CDATA[<p>MYDB被设计为C&#x2F;S结构，类似MySQL，支持启动一个服务器，被多个客户端链接，通过socket通信执行SQL语句返回结果。</p><h1 id="C-S通信"><a href="#C-S通信" class="headerlink" title="C&#x2F;S通信"></a>C&#x2F;S通信</h1><p>MYDB使用一种特殊的二进制格式用于双端通信（其实可以直接用明文）。<br>传输的基本结构是<code>Package</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pakage</span> &#123;<br><span class="hljs-type">byte</span>[] data;<br>Exception err;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个包体在被发送前都有<code>Encoder</code>编码为字节数组，在对方收到后同样会通过<code>Encoder</code>类解码为<code>Package</code>对象。<br>编码规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Flag]</span><span class="hljs-selector-attr">[data]</span><br></code></pre></td></tr></table></figure><p>若标志位flag为0，表示发送的是数据，data字段则为数据本身；如果flag为1，表示发送的是异常，data是<code>Exception.getMessage()</code>的错误提示信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] encode(Package pkg) &#123;<br>        <span class="hljs-keyword">if</span>(pkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> pkg.getErr();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Intern server error!&quot;</span>;<br>            <span class="hljs-keyword">if</span>(err.getMessage() != <span class="hljs-literal">null</span>) &#123;<br>                msg = err.getMessage();<br>            &#125;<br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>&#125;, msg.getBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>&#125;, pkg.getData());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(data.length &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length), <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length))));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码之后的信息会通过<code>Transporter</code>类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用<code>BufferedReader</code>和<code>Writer</code>来直接按行读写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transporter</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> BufferedReader reader;<br>    <span class="hljs-keyword">private</span> BufferedWriter writer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Transporter</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-built_in">this</span>.writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> hexEncode(data);<br>        writer.write(raw);<br>        writer.flush();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] receive() <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> reader.readLine();<br>        <span class="hljs-keyword">if</span>(line == <span class="hljs-literal">null</span>) &#123;<br>            close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> hexDecode(line);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writer.close();<br>        reader.close();<br>        socket.close();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">hexEncode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buf)</span> &#123;<br>        <span class="hljs-keyword">return</span> Hex.encodeHexString(buf, <span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] hexDecode(String buf) <span class="hljs-keyword">throws</span> DecoderException &#123;<br>        <span class="hljs-keyword">return</span> Hex.decodeHex(buf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL解析器</title>
    <link href="/2025-06-20/4beb296e4b5b/"/>
    <url>/2025-06-20/4beb296e4b5b/</url>
    
    <content type="html"><![CDATA[<h1 id="MYDB的SQL语法"><a href="#MYDB的SQL语法" class="headerlink" title="MYDB的SQL语法"></a>MYDB的SQL语法</h1><p>语句语法如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-variable">&lt;begin statement&gt;</span><br>    begin [isolation level (read committed|repeatable read)]<br>        begin isolation level read committed<br><br><span class="hljs-variable">&lt;commit statement&gt;</span><br>    commit<br><br><span class="hljs-variable">&lt;abort statement&gt;</span><br>    abort<br><br><span class="hljs-variable">&lt;create statement&gt;</span><br>    create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    ...<br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    [(index <span class="hljs-variable">&lt;field name list&gt;</span>)]<br>        create <span class="hljs-built_in">table</span> students<br>        id int32,<br>        name string,<br>        age int32,<br>        (index id name)<br><br><span class="hljs-variable">&lt;drop statement&gt;</span><br>    <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>        <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> students<br><br><span class="hljs-variable">&lt;select statement&gt;</span><br>    select (*|<span class="hljs-variable">&lt;field name list&gt;</span>) <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        select * <span class="hljs-keyword">from</span> student where id = <span class="hljs-number">1</span><br>        select name <span class="hljs-keyword">from</span> student where id &gt; <span class="hljs-number">1</span> and id <span class="hljs-variable">&lt; 4</span><br><span class="hljs-variable">        select name, age, id from student where id = 12</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">&lt;insert statement&gt;</span><br>    insert into <span class="hljs-variable">&lt;table name&gt;</span> values <span class="hljs-variable">&lt;value list&gt;</span><br>        insert into student values <span class="hljs-number">5</span> <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span> <span class="hljs-number">22</span><br><br><span class="hljs-variable">&lt;delete statement&gt;</span><br>    delete <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-variable">&lt;where statement&gt;</span><br>        delete <span class="hljs-keyword">from</span> student where name = <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span><br><br><span class="hljs-variable">&lt;update statement&gt;</span><br>    update <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;field name&gt;</span>=<span class="hljs-variable">&lt;value&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        update student <span class="hljs-built_in">set</span> name = <span class="hljs-string">&quot;ZYJ&quot;</span> where id = <span class="hljs-number">5</span><br><br><span class="hljs-variable">&lt;where statement&gt;</span><br>    where <span class="hljs-variable">&lt;field name&gt;</span> (&gt;|<span class="hljs-variable">&lt;|=) &lt;value&gt;</span> [(and|or) <span class="hljs-variable">&lt;field name&gt;</span> (&gt;|<span class="hljs-variable">&lt;|=) &lt;value&gt;</span>]<br>        where age &gt; <span class="hljs-number">10</span> or age <span class="hljs-variable">&lt; 3</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    [a-zA-Z][a-zA-Z0-<span class="hljs-number">9</span>_]*<br><br><span class="hljs-variable">&lt;field type&gt;</span><br>    int32 int64 string<br><br><span class="hljs-variable">&lt;value&gt;</span><br>    .*<br></code></pre></td></tr></table></figure><h1 id="解析器的实现"><a href="#解析器的实现" class="headerlink" title="解析器的实现"></a>解析器的实现</h1><p>MYDB使用一个<code>Parser</code>包体实现对SQL语句的结构画解析，将语句中包含的信息封装为对应语句的类对象。<br><code>Parser</code>中的<code>Tokenizer</code>类用于对语句进行逐字节解析，根据空白符或词法规则将语句切割为多个token，并对外提供<code>peek()</code>、<code>pop()</code>方法方便去除token解析。<br>Parser类则提供了<code>Parse(byte[] statement)</code>方法，通过调用一个<code>Tokenizer</code>类分割token，并根据词法规则包装成具体的statement类并返回。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事务的隔离级别</title>
    <link href="/2025-06-19/bb687791a5c8/"/>
    <url>/2025-06-19/bb687791a5c8/</url>
    
    <content type="html"><![CDATA[<h1 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h1><p>如果一个记录的最新版本被加上锁，另一个事务想要修改或读取该记录时，MYDB会返回一个数据的旧版本快照。此时可以认为被加锁的最新版本对于另一个事务来说不可见。于是版本可见性的概念就出现了。<br>版本可见性与事务的隔离程度相关。MYDB支持的最低事务隔离程度是“读提交”，即事务在读取数据时，只能读取已经提交事务产生的数据。为了实现读提交，为每个记录（版本）维护了<code>XMIN</code>和<code>XMAX</code>两个变量。<br>当想要删除一个版本时，只需要设置该版本的<code>XMAX</code>，这样，该版本对每一个<code>XMAX</code>之后的事务均不可见，也就等价于删除了。<br>在读提交下，版本对事务的可见性逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">(XIM == Ti &amp;&amp; <span class="hljs-comment">// 由Ti创建且</span><br>XMAX == NULL) <span class="hljs-comment">// 未被删除</span><br>||<br>(XMIN is committed &amp;&amp; <span class="hljs-comment">// 由一个已提交的事务创建且</span><br>(XMAX == NULL || <span class="hljs-comment">// 尚未删除或</span><br>(XMAX != Ti &amp;&amp; XMAX is not committed) <span class="hljs-comment">// 由一个未提交的事务删除</span><br>))<br></code></pre></td></tr></table></figure><p>若条件为真，则该版本对Ti可见，获取事务Ti适合的版本只需要从最新版本开始，依次向前检查可见性，只要为真就可直接返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readCommitted</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br><span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br><span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br><span class="hljs-keyword">if</span> (xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (tm.isCommitted(xmin)) &#123;<br><span class="hljs-keyword">if</span> (xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (xmax != xid) &#123;<br><span class="hljs-keyword">if</span> (!tm.isCommitted(xmax)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h1><p>读提交避免脏读后，但仍存在三类主要问题：</p><ol><li>不可重复读：同一事务内的多次相同查询会返回不同的结果，因为其他事务在两次查询之间修改并提交了数据。</li><li>幻读：同一事物内的范围查询返回了不同行数，因为其他事务插入或删除了符合条件的数据。</li><li>写倾斜：两个事务读取相同数据后，基于旧版本的值各自更新，导致最终结果违反业务约束。<br>不可重复读如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin<br><span class="hljs-title function_">R1</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// 读取x</span><br>T2 begin<br><span class="hljs-title function_">U2</span><span class="hljs-params">(X)</span> <span class="hljs-comment">// 修改了x的值</span><br>T2 commit<br><span class="hljs-title function_">R1</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// 读取到了不同值的x</span><br></code></pre></td></tr></table></figure>为了避免该情况，需要引入更严格的隔离级别，即可重复读。据此我们可以规定：<br><em><strong>事务只能读取它开始时就已经结束的事务所产生的数据版本。</strong></em><br>即事务需要额外忽略的数据版本有：</li><li>在本事务后开始的事务的数据</li><li>本事务开始时还是<code>active</code>状态的事务的数据<br>对于第一条只需要比较事务ID即可确定。第二条则需要在事务Ti开始时记录当前活跃的所有事物<code>SP(Ti)</code>，如果记录的某个版本其<code>XMIN</code>在<code>SP(Ti)</code>中，则该版本对Ti不可见。<br>因此可重复读的判断逻辑如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">(XMIN == Ti and <span class="hljs-comment">// 由Ti创建且 </span><br>(XMAX == <span class="hljs-literal">NULL</span>)) <span class="hljs-comment">// 尚未被删除</span><br>or <span class="hljs-comment">// 或 </span><br>(XMIN is commited and <span class="hljs-comment">// 由一个已提交的事务创建且 </span><br>XMIN &lt; XID and <span class="hljs-comment">// 这个事务小于Ti且 </span><br>XMIN is not in SP(Ti) and <span class="hljs-comment">// 这个事务在Ti开始前提交且 </span><br>(XMAX == <span class="hljs-literal">NULL</span> or <span class="hljs-comment">// 尚未被删除或 </span><br>(XMAX != Ti and <span class="hljs-comment">// 由其他事务删除但是 </span><br>(XMAX is not commited or <span class="hljs-comment">// 这个事务尚未提交或 </span><br> XMAX &gt; Ti or <span class="hljs-comment">// 这个事务在Ti开始之后才开始或 </span><br> XMAX is in SP(Ti) <span class="hljs-comment">// 这个事务在Ti开始前还未提交 </span><br>))))<br></code></pre></td></tr></table></figure>因此需要一个结构来抽象一个事务以保存快照数据：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> xid;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> level;<br><span class="hljs-keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;<br><span class="hljs-keyword">public</span> Exception err;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">int</span> level, Map&lt;Long,Transcation&gt; active)</span> &#123;<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>t.xid = xid;<br>t.level = level;<br><span class="hljs-keyword">if</span> (level != <span class="hljs-number">0</span>) &#123;<br>t.snapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Long x : active.keySet()) &#123;<br>t.snapshot.put(x.<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInSnapshot</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br><span class="hljs-keyword">if</span> (xid == TransactionManagerImpl.SUPER_XID) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> snapshot.containsKey(xid);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>构造方法中的active表中保存当前所有的活跃事务。因此在可重复读的隔离级别下，一个版本是否对事务可见的判断如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatableRead</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;<br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h1><p>MVCC的实现使得MYDB在撤销或回滚事务时很简单。只需要将该事务标记为<code>aborted</code>即可。根据记录的版本可见性设计，每个事务都只能看到其他已提交事务产生的数据，一个<code>aborted</code>事务产生的数据不会对其他事务产生任何影响。<br>对于版本跳跃问题有如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin<br>T2 begin<br><span class="hljs-title function_">R1</span><span class="hljs-params">(x)</span>-&gt;x0<br><span class="hljs-title function_">R2</span><span class="hljs-params">(x)</span>-&gt;x0<br><span class="hljs-title function_">U1</span><span class="hljs-params">(x)</span>-&gt;x1<br>T1 commit<br><span class="hljs-title function_">U2</span><span class="hljs-params">(x)</span>-&gt;x2<br>T2 commit<br></code></pre></td></tr></table></figure><p>该状况在运行时是没有问题的，后提交的事务将数据x覆盖为了x2，结果正确，但逻辑有所缺漏：T2中x0 -&gt; x2的过程忽略了T1中x0 -&gt; x1的更新，即x1的版本被跳过了。<br>可重复读是不允许版本跳跃的。解决版本条约的思路是：如果事务Ti需要修改数据x，而x已经被Ti不可见的事务修改了，那么要求事务Ti回滚。而事务Ti不可见的事务Tj有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)<br>因此版本跳跃的检查只需要对数据x的最新提交版本进行检测，查看最新版本的创建者对当前事务是否可见即可：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVersionSkip</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br><span class="hljs-keyword">if</span> (t.level == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2PL与MVCC</title>
    <link href="/2025-06-19/8c5e47f88f4a/"/>
    <url>/2025-06-19/8c5e47f88f4a/</url>
    
    <content type="html"><![CDATA[<h2 id="冲突与2PL"><a href="#冲突与2PL" class="headerlink" title="冲突与2PL"></a>冲突与2PL</h2><p>首先定义数据库的冲突。在不考虑插入操作，只看更新操作（U）和读操作（R），只要满足下面三个条件，就可以说这两个操作相互冲突：</p><ol><li>这两个操作由不同的事务执行</li><li>这两个操作的目标是同一个数据项</li><li>这两个操作至少有一个是更新操作<br>因此对同一个数据操作的冲突，只有两种情况：</li><li>两个不同事务的更新（U）冲突</li><li>两个不同事物的更新-读（U-R）冲突<br>两个事务是否相互冲突的区别是，<strong>交换两个互不冲突的操作的顺序，不会对最终效果造成影响</strong>，而交换两个相互冲突的操作会有影响：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin<br>T2 begin<br><span class="hljs-title function_">R1</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// T1读0</span><br><span class="hljs-title function_">R2</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// T2读0</span><br><span class="hljs-title function_">U1</span><span class="hljs-params">(<span class="hljs-number">0</span>+<span class="hljs-number">1</span>)</span> <span class="hljs-comment">// T1尝试X+1</span><br><span class="hljs-title function_">U2</span><span class="hljs-params">(<span class="hljs-number">0</span>+<span class="hljs-number">1</span>)</span> <span class="hljs-comment">// T2尝试X+1</span><br>T1 commit<br>T2 commit<br></code></pre></td></tr></table></figure>最后x的结果是1，结果与期望不符。<br>VM的一个重要功能就是实现了调度序列的可串行化。MYDB采用两段锁协议（2PL）实现。<br>采用2PL时，如果事务Ti已经对x加锁，且另一个事务Tj也打算操作x，但该操作与事务Ti之前的操作相互冲突的话，事务Tj就会被阻塞。 譬如，T1 已经因为<code>U1 (x)</code>锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。 由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</li></ol><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>在介绍 MVCC 之前，首先明确记录和版本的概念。<br>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。<br>MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p><h1 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h1><p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。<br>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMAX</span> <span class="hljs-operator">=</span> OF_XMIN+<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_XMAX+<span class="hljs-number">8</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> DataItem dataItem;<br>    <span class="hljs-keyword">private</span> VersionManager vm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>        <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        dataItem.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们规定一条Entry中存储的数据格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[XMIN]</span><span class="hljs-selector-attr">[XMAX]</span><span class="hljs-selector-attr">[DATA]</span><br></code></pre></td></tr></table></figure><p><code>XMIN</code>是创建该记录（版本）的事务编号，<code>XMAX</code>是删除该条记录（版本）的事务编号。<code>DATA</code>就是该记录持有的数据。根据这个结构创建记录的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapEntryRaw(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] xmin = Parser.long2Byte(xid);<br>    <span class="hljs-type">byte</span>[] xmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">return</span> Bytes.concat(xmin, xmax, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取记录中持有的数据也通过该结构解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以拷贝的形式返回内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data() &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[sa.end - sa.start - OF_DATA];<br>        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="hljs-number">0</span>, data.length);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要修改数据，需要对DataItem执行<code>before()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXmax</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>dataItem.before();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>System.arraycopy(Parser.long2Byte(xid, <span class="hljs-number">0</span>, sa.raw, sa.start + OF_XMAX, <span class="hljs-number">8</span>));<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>dataItem.after(xid);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DM模块的向上抽象：DataItem</title>
    <link href="/2025-06-18/7772fb057490/"/>
    <url>/2025-06-18/7772fb057490/</url>
    
    <content type="html"><![CDATA[<p>DataItem是DM层向上层提供的数据抽象。上层模块通过地址向DM请求到对应的DataItem，再获取到其中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataItemImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataItem</span> &#123;<br><span class="hljs-keyword">private</span> SubArray raw;<br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] oldRaw;<br><span class="hljs-keyword">private</span> DataManagerImpl dm;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br><span class="hljs-keyword">private</span> Page pg;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存一个DM的引用是因为DataItem的释放依赖于DM的释放（DM同时实现了用于缓存DataItem的接口），以及修改数据时写入日志。<br>DataItem中保存的数据结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ValidFlag]</span><span class="hljs-selector-attr">[DataSize]</span><span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure><p><code>ValidFlag</code>占1字节，标识该DataItem是否有效，删除一个DataItem，只需要将该有效位设置为0。<code>DataSize</code>占用2字节，表示之后Data长度。<br>上层模块再获取到DataItem后可以通过<code>data()</code>方法，该方法返回的数组是数据共享的<a href="%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84">SubArray</a>，而非拷贝实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SubArray <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上层模块试图对DataItem进行修改时，需要遵循一定流程：</p><ul><li>修改之前需要调用<code>before()</code>方法</li><li>撤销修改时需要调用<code>unbefore()</code>方法</li><li>修改完成后调用<code>after()</code>方法<br>该流程用于保存前相数据，并及时写日志，DM保证对DataItem的修改是原子性的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    wLock.lock();<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="hljs-number">0</span>, oldRaw.length);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unBefore</span><span class="hljs-params">()</span> &#123;<br>    System.arraycopy(oldRaw, <span class="hljs-number">0</span>, raw.raw, raw.start, oldRaw.length);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    dm.logDataItem(xid, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// 调用dm中的一个方法对修改操作落日志</span><br>    wLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>在使用完DataItem后，应当即使释放掉DataItem的缓存。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DM模块的页面索引</title>
    <link href="/2025-06-18/15bb3dd63e5b/"/>
    <url>/2025-06-18/15bb3dd63e5b/</url>
    
    <content type="html"><![CDATA[<p>页面索引<code>PageIndex</code>缓存了每一个数据页的空闲空间，用于在上层模块进行插入操作时，能快速找到一个合适空间的页面，无需从磁盘或缓存中检查每一个页面信息。<br>MYDB用一个比较粗略的算法实现了页面索引，将每一页的空间划分成了40个区间。在数据库启动时，会遍历所有的页面信息，获取页面的空闲空间安排到这40个区间中。使用<code>insert</code>请求一个页时，会先将所需的空间向上取整，映射到某一个区间，随后取出这个空间的任何一页，都可以满足需求。<br>页面索引的实现方式是一个List类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageIndex</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INNTERVALS_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;<br><br><span class="hljs-keyword">private</span> List&lt;PageInfo&gt;[] lists;<br>&#125;<br></code></pre></td></tr></table></figure><p>从页面索引中获取页面的方式则是通过页面大小算出区间号取出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> spaceSize)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> spaceSize / THRESHOLD;<br><span class="hljs-keyword">if</span> (number &lt; INTERVALS_NO) number++;<br><span class="hljs-keyword">while</span> (number &lt;= INTERVALS_NO) &#123;<br><span class="hljs-keyword">if</span> (lists[number].size() == <span class="hljs-number">0</span>) &#123;<br>number++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">return</span> lists[number].remove(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回的<code>PageInfo</code>中包含页号和空闲空间大小等信息。<br>被选择的页面会直接从页面索引中移除，因此同一个页面不允许并发写入。在上层模块使用完这个页面后，需要将其重新插入页面索引中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> freeSpace / THRESHOLD;<br>lists[number].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(pgno, freeSpace));<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据管理器被创建时，需要获取所有页面并填充页面索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化pageIndex</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPageIndex</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pageNumber</span> <span class="hljs-operator">=</span> pc.getPageNumber();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= pageNumber; i++) &#123;<br><span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>pg = pg.getPage(i);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>Panic.panic(e);<br>&#125;<br>pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));<br>pg.release();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用完Page后需要及时释放，否则可能会城堡缓存。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>另一种日志恢复策略</title>
    <link href="/2025-06-17/48a8550475e1/"/>
    <url>/2025-06-17/48a8550475e1/</url>
    
    <content type="html"><![CDATA[<p>对于[[日志恢复策略]]中提及的两种多线程下的数据库恢复问题，除了像MYDB一样对数据库操作进行限制，还可以对日志进行增强设计和额外的并发控制来解决问题。<br>第一类问题是事务T1的更新依赖于事务T2，但T2因未提交需要回滚，而已提交的T1被持久化处理，导致T1依赖的数据源失效。这被称为<strong>级联提交异常</strong>或<strong>脏读提交冲突</strong>。违反了事务的隔离性原则。<br>第二类问题是事务T1与T2并发更新同一数据项，而T2的更新覆盖了T1的更新，当T2提交，T1未提交时，重启操作会使T1的操作丢失。这被称作<strong>更新丢失</strong>或<strong>写-写冲突</strong>，是由于并发控制不足，没有正确处理写冲突导致部分事务的更新被覆盖。这是不可重复读问题的特里，违反了事务的原子性或持久性。<br>下述的策略在[[版本管理]]中有所实现。</p><h1 id="增强型日志设计"><a href="#增强型日志设计" class="headerlink" title="增强型日志设计"></a>增强型日志设计</h1><p>对于更新丢失问题，我们仅有两种的日志设计并不足以正确地恢复数据，因此我们引入新的日志类型来记录事务之间的锁信息和依赖关系：</p><ul><li><code>(Ti, L, A, mode)</code>：表示事务Ti在资源A上获取了mode类型的锁（如S锁或X锁）</li><li><code>(Ti, UL, A, mode)</code>：表示事务Ti释放了资源A上mode类型的锁</li><li><code>(Ti, D, Tj, A)</code>：表示事务Ti在资源A上依赖于事务Tj，即Tj先访问了A<br>当事务执行时，除了记录原有的更新日志，还需要记录锁操作和依赖关系：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 <span class="hljs-title function_">begin</span> <span class="hljs-params">(T1, B)</span> <span class="hljs-comment">// 事务开始日志 </span><br><br>T2 <span class="hljs-title function_">begin</span> <span class="hljs-params">(T2, B)</span> <br><br>T1 <span class="hljs-built_in">set</span> x = x + <span class="hljs-number">1</span> (T1, L, x, X) <span class="hljs-comment">// T1获取x的排他锁 </span><br>(T1, D, null, x) <span class="hljs-comment">// T1不依赖其他事务 </span><br>(T1, U, x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 原更新日志 </span><br><br>T2 <span class="hljs-built_in">set</span> x = x + <span class="hljs-number">1</span> (T2, L, x, X) <span class="hljs-comment">// T2尝试获取x的排他锁 </span><br>(T2, D, T1, x) <span class="hljs-comment">// T2依赖于T1（需等待T1释放锁） </span><br>(T2, U, x, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 记录更新（此时x=1是基于T1的结果） </span><br><br>T2 commit (T2, UL, x, X) <span class="hljs-comment">// T2释放锁 </span><br>(T2, C) <span class="hljs-comment">// 事务提交日志</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="恢复机制改进"><a href="#恢复机制改进" class="headerlink" title="恢复机制改进"></a>恢复机制改进</h1><p>当系统崩溃重启时，会按照以下步骤操作：</p><ol><li><strong>重做阶段</strong><ul><li>按时间顺序扫描日志，重做所有已提交事务（包括其锁操作）</li><li>对于依赖日志，确保依赖的事务先被处理</li></ul></li><li><strong>撤销阶段</strong><ul><li>按逆序撤销未提交事务</li><li>利用锁日志恢复锁状态，确保撤销操作的原子性</li></ul></li><li><strong>处理依赖关系</strong><ul><li>当遇到依赖日志<code>(Ti, D, Tj, A)</code>时：<ul><li>如果 Tj 已提交，Ti 可以继续执行</li><li>如果 Tj 未提交，Ti 必须被撤销</li></ul></li></ul></li></ol><h1 id="严格两段锁协议-Strict-2PL"><a href="#严格两段锁协议-Strict-2PL" class="headerlink" title="严格两段锁协议(Strict 2PL)"></a>严格两段锁协议(Strict 2PL)</h1><p>对于级联提交异常问题，之前的增强日志设计无法完全解决该问题：</p><ul><li>日志系统只能记录和恢复操作，但无法改变已提交事务的状态，将已提交的事务回滚（即使能修改，也违反了事务的持久性）</li><li>锁机制在原始场景中可能没有严格执行，导致事务能读取未提交事务的数据<br>使用严格两阶段锁协议和多版本并发控制可以解决该问题。<br><strong>规范要求</strong><br>要求事务在释放写锁之前不能提交，并且所有锁在事务提交后必须释放。<br>这一规范下：</li><li>当T2在提交前持有数据x的写锁时，T1无法读取x</li><li>若T1需要读取x，必须等待T2提交以避免脏读<br><strong>核心原理</strong><br>2PL要求事务由两种持有锁的方式：</li></ul><ol><li>加锁阶段：事务只能申请锁，不能释放锁</li><li>解锁阶段：事务只能释放锁，不能申请新锁<br><strong>锁类型</strong></li></ol><ul><li>共享锁（S锁、读锁）：允许多个事务同时读同意数据，不阻塞其他S锁，但阻塞X锁。</li><li>排他锁（X锁，写锁）：独占数据，阻塞其他所有锁。</li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><strong>锁管理器</strong></p><ul><li>维护锁表，记录每个数据项的锁状态和持有者</li><li>处理锁请求和释放操作<br><strong>事务状态跟踪</strong></li><li>事务开始时进入加锁阶段，结束时进入解锁阶段，违反两阶段规则的锁请求会被拒绝<br><strong>死锁处理</strong></li><li>预防：按照固定顺序申请锁，或使用超时机制</li><li>检测与回滚：通过等待图检测死锁，回滚代价最小的事务<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin<br>T2 begin<br>T2 X-lock(x) <span class="hljs-comment">// T2获取x的写锁</span><br>T2 <span class="hljs-title function_">U</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// 更新x</span><br>T1 request S-<span class="hljs-title function_">lock</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// T1请求读锁，被阻塞</span><br>T2 commit <span class="hljs-comment">// T2提交并释放锁</span><br>T1 acquires S-<span class="hljs-title function_">lock</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// T1获得读锁</span><br>T1 <span class="hljs-title function_">R</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// 读取已被提交的X</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h1><p><strong>核心原理</strong><br>数据库为每个数据项维护多个版本，每个版本带有时间戳或者事务ID。</p><ul><li>读操作：访问历史版本，无需加锁处理，避免阻塞写操作。</li><li>写操作：创建新版本，而非字节覆盖旧版本。<br><strong>版本控制方式</strong></li></ul><ol><li>时间戳排序<ul><li>每个事务分配一个唯一时间戳&#x2F;ID，读写操作按照时间戳顺序进行</li><li>若操作违反了时间戳顺序，事务回滚</li></ul></li><li>乐观并发控制<ul><li>事务执行时不加锁，提交前检查是否有冲突，如果冲突，回滚并重试</li></ul></li><li>快照隔离<ul><li>事务开始时获取数据的快照，后续的读操作均基于快照处理，以避免脏读和不可重复读。</li></ul></li></ol><h2 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h2><p><strong>版本链</strong><br>每个数据项维护一个版本链表，指向其历史版本。新版本通过指针链接到旧版本，形成时间顺序。<br><strong>可见性判断</strong><br>读操作根据事务ID和版本时间戳来判断哪些版本对当前事务可见，例如<code>PostgreSQL</code>使用事务ID位图快速判断版本可见性。<br><strong>垃圾回收</strong><br>定期清理不可见的旧版本，释放存储空间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>日志恢复策略</title>
    <link href="/2025-06-17/f97fb2a2d350/"/>
    <url>/2025-06-17/f97fb2a2d350/</url>
    
    <content type="html"><![CDATA[<p>恢复策略来自NYADB2的恢复策略。DM为上层模块提供了两种操作，分别是插入新数据（I操作）和更新现有数据（U操作），而没有删除数据（在版本管理时再作解释）。<br>DM的日志策略可以用一句话概括：<br><em><strong>在进行 I 和 U 操作之前，必须先进行对应的日志操作，确保日志被写入磁盘后，才进行数据操作。</strong></em><br>这一日志策略使DM对数据操作的磁盘同步能够更加随意，日志在数据操作前就到达了 磁盘，那么即使该数据操作没有及时同步到磁盘，后续也可以通过磁盘上的日志文件恢复该数据。<br>对于两种数据操作，DM对应的日志记录为：</p><ul><li><code>(Ti, I, A, x)</code>：表示事务Ti在A位置插入一条数据x</li><li><code>(Ti, U, A, oldx, newx)</code>：表示事务Ti将A位置的数据从oldx更新为newx</li></ul><h1 id="单线程情况"><a href="#单线程情况" class="headerlink" title="单线程情况"></a>单线程情况</h1><p>在不考虑并发的情况下，某一时刻只有一个事务在操作数据库，日志结构会像如下情况：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(Ti<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">,</span> (Ti<span class="hljs-punctuation">,</span> xN<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> (Tj<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">,</span> (Tj<span class="hljs-punctuation">,</span> xN<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> (Tk<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">,</span> (Tk<span class="hljs-punctuation">,</span> xN<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure><p>由于单线程，不同事务的日志永远不会相交，此时利用日志恢复数据库很简单。<br>假设日志中最后一个事务是Ti：</p><ul><li>对Ti之前所有的事务日志进行重做</li><li>通过<code>.xid</code>文件检查Ti的状态，如果Ti的状态是已完成（即<code>committed</code>或<code>aborted</code>）就重做，否则撤销Ti<br>对单个事务T进行重做的流程为：</li><li>正序扫描事务T的所有日志</li><li>如果日志是插入操作<code>(Ti, I, A, x)</code>，就将x重新插入A位置</li><li>如果日志是更新操作<code>(Ti, U, A, oldx, newx)</code>，就将A位置的值设置为newx<br>事务T的撤销流程则是：</li><li>倒序扫描事务T的所有日志</li><li>如果日志是插入操作<code>(Ti, I, A, x)</code>，就将A位置的数据删除</li><li>如果日志是更新操作<code>(Ti, U, A, oldx, newx)</code>，就将A位置的值设置为oldx<br>MYDB中没有真正的删除操作，对于插入操作的撤销，只是将其中的标志位设置为invalid。对删除的探讨会在版本管理中进行。</li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>由于多线程的时序操作复杂，因此我们根据可能出现的多个情况进行讨论。<br>第一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin <br>T2 begin <br>T2 <span class="hljs-title function_">U</span><span class="hljs-params">(x)</span> <br>T1 <span class="hljs-title function_">R</span><span class="hljs-params">(x)</span> <br>...<br>T1 commit <br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>当数据库崩溃时，T2仍然是活跃状态，那么当数据库重启时，会将T2撤销，但由于T1读取了T2更新后的值，若T2被撤销，那么T1也应当被撤销（即级联回滚），但T1已经被提交，而所有已提交的事务，其影响都应持久化，此处则会产生矛盾。<br>为了避免该矛盾问题，我们规定：<br><em><strong>规范 1：正在进行的事务，不会读取其他任何未提交的事务所产生的数据。</strong></em><br>还有第二种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">T1 begin<br>T2 begin<br>T1 <span class="hljs-built_in">set</span> x = x + <span class="hljs-number">1</span> <span class="hljs-comment">// (T1, U, A, 0, 1)</span><br>T2 <span class="hljs-built_in">set</span> x = x + <span class="hljs-number">1</span> <span class="hljs-comment">// (T2, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>系统崩溃重启时会撤销T1，重做T2，但无论撤销与重做顺序如何，x最后的结果要么是0要么是2，这是错误的（应当是T1执行完毕后的1）。出现该问题的原因归根结底是我们的日志设计太过简单，仅仅记录了前相和后相，并单纯地靠正序倒序进行重做和撤销，这种简单的日志和恢复方式无法涵盖所有数据库操作形成的语义。<br>对于该类错误有两种解决办法：</p><ul><li>增加日志种类</li><li>限制数据库操作<br>MYDB使用的是限制数据库操作，那么就需要我们进一步规定：<br><em><strong>规范 2：正在进行的事务，不会修改其他任何未提交的事务正在修改或产生的数据。</strong></em><br>在 MYDB 中，由于 VM 的存在，传递到 DM 层，真正执行的操作序列，都可以保证规定 1 和规定 2。VM 如何保证这两条规定，会在 VM 层一节中说明。<br>有了这两条规定，并发情况下日志的恢复也就很简单了： </li><li>重做所有崩溃时已完成（committed 或 aborted）的事务 </li><li>撤销所有崩溃时未完成（active）的事务<br>在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[另一种日志恢复策略]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>日志文件</title>
    <link href="/2025-06-17/c1dd335ff70e/"/>
    <url>/2025-06-17/c1dd335ff70e/</url>
    
    <content type="html"><![CDATA[<p>MYDB以日志文件为基础提供了崩溃后的数据恢复功能。DM层在每次对底层数据进行操作后，都会记录一条日志到磁盘上，当崩溃重启时，可以根据日志内容恢复数据文件，保证一致性。</p><h1 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h1><p>日志的二进制文件按照如下格式排布：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[XChecksum]</span><span class="hljs-selector-attr">[Log1]</span><span class="hljs-selector-attr">[Log2]</span><span class="hljs-selector-attr">[Log3]</span>...<span class="hljs-selector-attr">[LogN]</span><span class="hljs-selector-attr">[BadTail]</span><br></code></pre></td></tr></table></figure><p>其中<code>XChecksum</code>是一个4字节int整数，是对后续所有日志计算得出的校验和。<code>Log1-N</code>是常规的日志数据，<code>BadTail</code>是数据库崩溃时未完全写入的日志数据，不一定存在。<br>每一条的日志<code>Log</code>格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Size]</span><span class="hljs-selector-attr">[Checksum]</span><span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure><p><code>Size</code>是一个4字节int整数，标识了<code>Data</code>段的字节数，<code>Checksum</code>则是该条日志的校验和。单条日志的校验和通过指定一个种子实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>xCheck = xCheck * SEED + b;<br>&#125;<br><span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure><p>对所有日志条目的校验和求和便能得到<code>XChecksum</code>，即<code>.log</code>文件的开头校验和。<br>日志管理器Logger被实现为迭代器模式，通过<code>next()</code>方法不断从文件中读取下一条日志，并将其中的Data解析出来后返回。<code>next()</code>方法的实现主要依靠<code>internNext()</code>，其中<code>position</code>是当前日志文件读到的位置偏移：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br><span class="hljs-keyword">if</span> (position + OF_DATA &gt;= fileSize) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 读取size</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>fc.position(position);<br>fc.read(tmp);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br><span class="hljs-keyword">if</span> (position + size + OF_DATA &gt; fileSize) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 读取checksum + data</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>fc.position(position);<br>fc.read(buf);<br><span class="hljs-type">byte</span>[] log = buf.array();<br><br><span class="hljs-comment">// 校验checksum</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br> <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br> <span class="hljs-keyword">if</span> (checkSum1 != checkSum2) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> position += log.length;<br> <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure><p>在打开一个日志文件时，首先需要校验日志文件的校验和，并移除文件尾部可能存在的BadTail，由于BadTail尚未写入完成，文件校验和也不会包含该条日志的校验和，去掉BadTail便能保证日志文件一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>rewind();<br><span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">byte</span>[] log = internNext();<br><span class="hljs-keyword">if</span> (log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>xCheck = calChecksum(xCheck, log);<br>&#125;<br><span class="hljs-keyword">if</span> (xCheck != xChecksum) Panic.panic(Error.BadLogFileException);<br><br><span class="hljs-comment">// 截断文件到正常日志结尾</span><br>truncate(position);<br>rewind();<br>&#125;<br></code></pre></td></tr></table></figure><p>向日志文件写入日志时，首先将数据包裹为日志格式，写入文件后再更新文件校验和。更新校验和时需要刷新缓冲区，保证内容写入磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br><span class="hljs-type">byte</span>[] log = wrapLog(data);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>fc.position(fc.size());<br>fc.write(buf);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>Panic.panic(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br><span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>fc.position(<span class="hljs-number">0</span>);<br>fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br><span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br><span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br><span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[日志恢复策略]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DM模块的向下抽象</title>
    <link href="/2025-06-17/4e6ee98919ea/"/>
    <url>/2025-06-17/4e6ee98919ea/</url>
    
    <content type="html"><![CDATA[<p>数据管理(Data Manager)将文件系统抽象成页面类，每次对文件系统的读写都以页面为单位，从文件系统读入的数据也是以页面为单位进行缓存。</p><h1 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h1><p>MYDB参考大部分数据库的设计将默认数据页大小定为8K，如果想要提升向数据库写入大量数据时的性能，可以适当增大该值。本模块需要对页面进行缓存，因此使用<a href="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6">自行设计的缓存框架</a>。该页面是存储在内存中的，与已经持久化存储在磁盘的抽象页有区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;<br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> PageCache pc;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pageNumber</code>是该页面的页号，页号从1开始。<code>data</code>是该页实际包含的字节数据。<code>dirty</code>标志该页面是否为脏页面；缓存驱逐时，脏页面需要被写回磁盘。<code>PageCache</code>引用用来在拿到Page的引用后可以快速对该页面缓存进行释放。<br>页面缓存PageCache的接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存在具体实现时需要继承抽象缓存框架并实现两个抽象方法。由于数据源就是文件系统，<code>getForCache()</code>直接从文件中读取，并包裹为Page对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br><span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>fileLock.lock(); <br><span class="hljs-keyword">try</span> &#123; <br>fc.position(offset);<br>fc.read(buf); <br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123; Panic.panic(e); &#125; <br>fileLock.unlock(); <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>); <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123; <span class="hljs-comment">// 页号从 1 开始 </span><br><span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>releaseForCache()</code>驱逐页面时，也只需要根据页面是否dirty来决定是否需要写回文件系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br><span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>flush(pg);<br>pg.setDirty(<span class="hljs-literal">false</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br><span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br>fileLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>fc.position(offset);<br>fc.write(buf);<br>fc.force(<span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; Panic.panic(e); &#125;<br><span class="hljs-keyword">finally</span> &#123;<br>fileLock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PageCache还使用一个<code>AtomicInteger</code>用于记录当前打开的数据库文件有多少页，该数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br><span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>flush(pg); <span class="hljs-comment">// 新建的页面需要被立刻写回</span><br><span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这一设计中，同一条数据不允许跨页面存储，因此单条数据的大小不能超过数据页面的大小。</p><h1 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h1><h2 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h2><p>数据库文件的第一页常用于一些特殊用途，例如存储元数据用于启动检查。MYDB的第一页数据页同样如此。具体原理是，在每次数据库启动时会生成一段随机字节，储存在第一页的100-107字节，数据库正常关闭时，会将该字节拷贝到第一页的108-115字节。数据库在每次启动时就会检查第一页两处的字节是否相同，以此判断上一次是否正常关闭，如果是异常关闭，则需要执行数据恢复流程。<br>启动时设置初始字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>pg.setDirty(<span class="hljs-literal">true</span>);<br>setVcOpen(pg.getData());<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭的时候拷贝随机字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>pg.setDirty(<span class="hljs-literal">true</span>);<br>setVcClose(pg.getData());<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>System.arraycopy(raw, OF_VC, raw, OF_VC + LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>字节校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">chechVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>retrun <span class="hljs-title function_">checkVc</span><span class="hljs-params">(pg.getData()</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br><span class="hljs-keyword">return</span> Arrays.equals(<br>Arrays.copyOfRange(raw, OF_VC, OF_VC + LEN_VC),<br>Arrays.copyOfRange(raw, OF_VC + LEN_VC, OF_VC + <span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h2><p>MYDB中，一个普通页面以一个2字节无符号数起始，表示该页的空闲位置的偏移(Free Space Offset），其余部分都是实际存储的数据。对普通页的管理，基本都是围绕对FSO进行的。<br>例如向页面插入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>pg.setDirty(<span class="hljs-literal">true</span>);<br><span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br><span class="hljs-keyword">return</span> offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>在写入之前获取FSO来确定写入的位置，并在写入后更新FSO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br><span class="hljs-keyword">return</span> getFSO(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br><span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br><span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>&#125;<br></code></pre></td></tr></table></figure><p>剩余两个函数<code>recoverInsert()</code>和<code>recoverUpdate()</code>用于在数据库崩溃重启时恢复例程直接插入数据以及修改数据使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的那个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg,<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>pg.setDirty(<span class="hljs-literal">true</span>);<br>System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br><span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br><span class="hljs-keyword">if</span> (rawFSO &lt; offset + raw.length) <br>setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>&#125;<br><br><span class="hljs-comment">// 将raw插入pg中的offset位置，不更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>pg.setDirty(<span class="hljs-literal">true</span>);<br>System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>共享内存数组</title>
    <link href="/2025-06-17/b245750f24b5/"/>
    <url>/2025-06-17/b245750f24b5/</url>
    
    <content type="html"><![CDATA[<p>Java中将数组看作一个对象，在内存中，数组也是以对象的形式存储的，而 C、C++、Go等语言，数组是通过指针实现的，因此会出现一个情况：没法对同一片内存进行分区引用，Java在执行类似subArray操作时，底层只会执行一次复制，而非指向同一片内存空间。因此需要一个<code>SubArray</code>类来松散地规定一个数组的可使用范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubArray</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] raw;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SubArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br><span class="hljs-built_in">this</span>.raw = raw;<br><span class="hljs-built_in">this</span>.start = start;<br><span class="hljs-built_in">this</span>.end = end;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>引用计数缓存框架</title>
    <link href="/2025-06-17/60e1c630d6ff/"/>
    <url>/2025-06-17/60e1c630d6ff/</url>
    
    <content type="html"><![CDATA[<p>由于数据管理(Data Manager)中的分野管理和数据项(DataItem)管理都设计缓存，因此需要设计一个更通用的缓存框架。这里采用引用计数缓存，而非LRU策略缓存。<br>这里首先从缓存的接口设计说起，如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。<br>设想这样一个场景：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这时候就陷入了一种尴尬的境地：是否有必要做回源操作？ </p><ul><li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的 </li><li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源 放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题<br>当然我们可以记录下资源的最后修改时间，并且让缓存记录下资源被驱逐的时间。但是如无必要，无增实体。<br>问题的根源还是，LRU 策略中，<strong>资源驱逐不可控，上层模块无法感知</strong>。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。 这就是引用计数法了。增加了一个方法 release(key) ，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。 同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 一样，直接 OOM）。、</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>MYDB中我们会实现一个<code>AbstractCache&lt;T&gt;</code>抽象类，并设计两个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 资源不在缓存时的获取行为</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">// 资源被驱逐时的写回行为</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure><p>除了普通的缓存功能，框架还需要维护每个资源的引用计数，为了应对多线程场景，还需要记录哪些资源正在从数据源中被获取（获取资源是一个相对费时的操作），于是需要设计如下三个Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache; <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references; <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting; <span class="hljs-comment">// 正在被获取的资源</span><br></code></pre></td></tr></table></figure><p>在通过<code>get()</code>方法获取资源时，需要进入一个死循环来无限尝试从缓存里获取。首先需要检查此时是否有其他线程正在从数据源获取该资源（getting里是否有对应资源），如果有，就让线程休眠短暂时间，过段时间再继续循环。<br>如果资源在缓存中，可以直接获取并返回，并给资源的引用计数+1，否则，如果缓存没满时，就先在getting中注册该资源，并开始<code>getForCache()</code>。获取完成后要记得从getting中删除对应key。<br>释放一个缓存则直接让引用计数-1，如果减到0则可以回源，并删除缓存中所有相关的结构。<br>缓存还应当有一个安全关闭的功能，关闭时需要将缓存中的所有资源强制回源。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字段和表管理</title>
    <link href="/2025-06-16/84e514291989/"/>
    <url>/2025-06-16/84e514291989/</url>
    
    <content type="html"><![CDATA[<p>此处的字段与表管理是指管理表和字段的数据结构，例如表名、表字段信息、字段索引等，不是管理各个条目中不同字段的数值信息。<br>由于TBM依赖于VM，单个字段信息和表信息都直接保存在了Entry中。<br>字段的二进制表示如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[FieldName]</span><span class="hljs-selector-attr">[TypeName]</span><span class="hljs-selector-attr">[IndexUid]</span><br></code></pre></td></tr></table></figure><p>三部分内容存储的都是字节形式的字符串。这里额外规定字符串的存储方式以明确存储边界：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[StringLength]</span><span class="hljs-selector-attr">[StringData]</span><br></code></pre></td></tr></table></figure><p><code>TypeName</code>是字段的类型，限定为<code>int32</code>、<code>int64</code>和<code>string</code>类型。如果该字段有索引，那么<code>IndexUid</code>会指向索引二叉树的根，否则为0。<br>根据该结构，通过一个UID从VM中读取并解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title function_">loadField</span><span class="hljs-params">(Table tb, <span class="hljs-type">long</span> uid)</span> &#123;<br>    <span class="hljs-type">byte</span>[] raw = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">assert</span> raw != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(uid, tb).parseSelf(raw);<br>&#125;<br><br><span class="hljs-keyword">private</span> Field <span class="hljs-title function_">parseSelf</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ParseStringRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Parser.parseString(raw);<br>    fieldName = res.str;<br>    position += res.next;<br>    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));<br>    fieldType = res.str;<br>    position += res.next;<br>    <span class="hljs-built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="hljs-number">8</span>));<br>    <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个字段的方法类似，将相关信息通过VM持久化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persistSelf</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);<br>    <span class="hljs-type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);<br>    <span class="hljs-type">byte</span>[] indexRaw = Parser.long2Byte(index);<br>    <span class="hljs-built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数据库中存在多个表，TBM使用链表的形式将数据库中的表组织起来，每一个表都保存一个指向下一张表的UID。表的二进制结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[TableName]</span><span class="hljs-selector-attr">[NextTable]</span><br><span class="hljs-selector-attr">[Field1Uid]</span><span class="hljs-selector-attr">[Field2Uid]</span>...<span class="hljs-selector-attr">[FieldNUid]</span><br></code></pre></td></tr></table></figure><p>由于每个Entry中的数据字节大小是去欸的那个的，因此无需保存字段的数目。根据UID从Entry中读取表数据的过程和读取字段的过程类似。<br>对表和字段的操作的一个重要步骤就是计算<code>where</code>条件的范围。目前MYDB的<code>where</code>只支持两个条件的<code>&amp;&amp;</code>和<code>||</code>，同时只支持已索引字段作为<code>where</code>的条件。<br>计算该范围是<code>Table</code>类中的<code>parseWHere()</code>与<code>calWhere()</code>方法，以及<code>Field</code>类的<code>calExp()</code>方法。<br>由于 TBM 的表管理使用的是链表串起的<code>Table</code>结构，所以必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。<br>MYDB 使用<code>Booter</code>类和<code>.bt</code>文件来管理 MYDB 的启动信息，虽然现在所需的启动信息只有一个：头表的 UID。<br><code>Booter</code>类对外提供了两个方法<code>load()</code> 和<code>update()</code>，并保证了其原子性。<code>update()</code> 在修改<code>.bt</code>文件内容时，没有直接对<code>.bt</code>文件进行修改，而是首先将内容写入一个 <code>.bt_tmp</code>文件中，随后将这个文件重命名为<code>.bt</code>文件，以期通过操作系统重命名文件的原子性，来保证操作的原子性。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path + BOOTER_TMP_SUFFIX);<br>    <span class="hljs-keyword">try</span> &#123;<br>        tmp.createNewFile();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(tmp)) &#123;<br>        out.write(data);<br>        out.flush();<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.move(tmp.toPath(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX);<br>    <span class="hljs-keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h1><p>TBM 层对外提供服务如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableManager</span> &#123;<br>    BeginRes <span class="hljs-title function_">begin</span><span class="hljs-params">(Begin begin)</span>;<br>    <span class="hljs-type">byte</span>[] commit(<span class="hljs-type">long</span> xid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] abort(<span class="hljs-type">long</span> xid);<br><br>    <span class="hljs-type">byte</span>[] show(<span class="hljs-type">long</span> xid);<br>    <span class="hljs-type">byte</span>[] create(<span class="hljs-type">long</span> xid, Create create) <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">byte</span>[] insert(<span class="hljs-type">long</span> xid, Insert insert) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, Select select) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] update(<span class="hljs-type">long</span> xid, Update update) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] delete(<span class="hljs-type">long</span> xid, Delete delete) <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C&#x2F;S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。 各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的时头插法，所以每次创建表都需要更新 Booter 文件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>索引管理</title>
    <link href="/2025-06-16/266bf6e8430a/"/>
    <url>/2025-06-16/266bf6e8430a/</url>
    
    <content type="html"><![CDATA[<p>索引管理器位MYDB提供了基于B+树的聚簇索引。目前MYDB只支持基于索引查找数据，不支持全表扫描。IM直接依赖于<a href="%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">DM</a>，而没有基于VM。索引的数据会被直接插入数据库文件中，不需要经过版本管理。</p><h1 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h1><p>二叉树由多个节点Node组成，每个Node都存储在一条DataItem中。结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[LeadFlag]</span><span class="hljs-selector-attr">[KeyNumber]</span><span class="hljs-selector-attr">[SiblingUid]</span><br><span class="hljs-selector-attr">[Son0]</span><span class="hljs-selector-attr">[Key0]</span><span class="hljs-selector-attr">[Son1]</span><span class="hljs-selector-attr">[Key1]</span>...<span class="hljs-selector-attr">[SonN]</span><span class="hljs-selector-attr">[KeyN]</span><br></code></pre></td></tr></table></figure><p>其中<code>LeafFlag</code>标记了该系欸但是否是叶节点；<code>KeyNumber</code>为该节点中Key的数目，<code>SiblingUid</code>是其兄弟节点存储在DM中的UID。后续是该节点穿插的子节点和对应的Key。最后的一个KeyN始终为<code>MAX_VALUE</code>，方便查找。<br>Node类持有了其B+树结构的引用，DataItem的引用和SubArray的引用，方便快速修改和释放数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>BPlusTree tree;<br>DataItem dataItem;<br>SubArray raw;<br><span class="hljs-type">long</span> uid;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>生成一个根节点的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newRootRaw(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> key)  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>    setRawIsLeaf(raw, <span class="hljs-literal">false</span>);<br>    setRawNoKeys(raw, <span class="hljs-number">2</span>);<br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>    setRawKthSon(raw, left, <span class="hljs-number">0</span>);<br>    setRawKthKey(raw, key, <span class="hljs-number">0</span>);<br>    setRawKthSon(raw, right, <span class="hljs-number">1</span>);<br>    setRawKthKey(raw, Long.MAX_VALUE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p>该根节点的两个初始子节点为<code>left</code>和<code>right</code>，初始键值为<code>key</code>。<br>类似的，生成一个空的根节点数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newNilRootRaw()  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>    setRawIsLeaf(raw, <span class="hljs-literal">true</span>);<br>    setRawNoKeys(raw, <span class="hljs-number">0</span>);<br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p>Node类有两个方法，用于辅助B+树做插入和搜索操作，分别是<code>searchNext()</code>和<code>leafSearchRange()</code>。<br><code>searchNext()</code>方法寻找对应key的UID，如果找不到，则返回兄弟节点的UID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SearchNextRes <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SearchNextRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchNextRes</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; noKeys; i ++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, i);<br>            <span class="hljs-keyword">if</span>(key &lt; ik) &#123;<br>                res.uid = getRawKthSon(raw, i);<br>                res.siblingUid = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        res.uid = <span class="hljs-number">0</span>;<br>        res.siblingUid = getRawSibling(raw);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>leafSearchRange()</code>方法在当前节点进行范围查找，范围是<code>[leftKey, rightKey]</code>，我们约定如果<code>rightKey</code>大于等于该节点的最大的key，则同时返回兄弟节点的UID，以便继续搜索下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LeafSearchRangeRes <span class="hljs-title function_">leafSearchRange</span><span class="hljs-params">(<span class="hljs-type">long</span> leftKey, <span class="hljs-type">long</span> rightKey)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>            <span class="hljs-keyword">if</span>(ik &gt;= leftKey) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            kth ++;<br>        &#125;<br>        List&lt;Long&gt; uids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>            <span class="hljs-keyword">if</span>(ik &lt;= rightKey) &#123;<br>                uids.add(getRawKthSon(raw, kth));<br>                kth ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">siblingUid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(kth == noKeys) &#123;<br>            siblingUid = getRawSibling(raw);<br>        &#125;<br>        <span class="hljs-type">LeafSearchRangeRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafSearchRangeRes</span>();<br>        res.uids = uids;<br>        res.siblingUid = siblingUid;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>B+树在插入和删除时会动态调整，使得根节点不会固定，因此设置一个<code>bootDataItem</code>，该DataItem中存储了根节点的UID。可以注意到索引管理在操作DM时，使用的事务都是<code>SUPER_XID</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPlusTree</span> &#123;<br>    DataItem bootDataItem;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">rootUid</span><span class="hljs-params">()</span> &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            <span class="hljs-keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="hljs-number">8</span>));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateRootUid</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> rightKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newRootUid</span> <span class="hljs-operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);<br>            bootDataItem.before();<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">diRaw</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            System.arraycopy(Parser.long2Byte(newRootUid), <span class="hljs-number">0</span>, diRaw.raw, diRaw.start, <span class="hljs-number">8</span>);<br>            bootDataItem.after(TransactionManagerImpl.SUPER_XID);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。 这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其<code>XMAX</code>。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了<code>XMAX</code>，寻找不到合适的版本而返回一个找不到内容的错误。</p><h1 id="可能的错误与恢复"><a href="#可能的错误与恢复" class="headerlink" title="可能的错误与恢复"></a>可能的错误与恢复</h1><p>B+树在操作过程里可能出现两种错误，分别是节点内部错误和节点间关系错误。<br>当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。<br>如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling (u)&#x3D;v，但是 v 却并没有被插入到父节点中。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[parent]</span><br>   |<br>   V<br>  <span class="hljs-comment">[u]</span> -&gt; <span class="hljs-comment">[v]</span><br></code></pre></td></tr></table></figure><p>正确的状态应当如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"> <span class="hljs-comment">[parent]</span><br> |      |<br> V      V<br><span class="hljs-comment">[u]</span> -&gt; <span class="hljs-comment">[v]</span><br></code></pre></td></tr></table></figure><p>这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理</title>
    <link href="/2025-06-16/8f679726d275/"/>
    <url>/2025-06-16/8f679726d275/</url>
    
    <content type="html"><![CDATA[<h1 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h1><p><code>DataManager</code>是DM层直接对外提供方法的类，也同时实现DataItem对象的缓存。DataItem存储的key是由页号和页内偏移组成的一个8字节无符号整数，页号和偏移各占4字节。<br><code>getForCache() </code>方法只需要从 key 中解析出页号，从pageCache中获取到页面，再根据偏移，解析出DataItem即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> DataItem <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> pc.getPage(pgno);<br>    <span class="hljs-keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>DataItem缓存释放，需要将DataItem写回数据源，由于对文件的读写是以页为单位进行的，只需要将DataItem所在的页释放即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(DataItem di)</span> &#123;<br>    di.page().release();<br>&#125;<br></code></pre></td></tr></table></figure><p>从已有文件创建DataManager和从空文件创建DataManager的流程稍有不同，除了PageCache和Logger的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.create(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.create(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    dm.initPageOne();<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.open(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.open(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    <span class="hljs-keyword">if</span>(!dm.loadCheckPageOne()) &#123;<br>        Recover.recover(tm, lg, pc);<br>    &#125;<br>    dm.fillPageIndex();<br>    PageOne.setVcOpen(dm.pageOne);<br>    dm.pc.flushPage(dm.pageOne);<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，初始化第一页，和校验第一页，基本都是调用<code>PageOne</code>类中的方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建文件时初始化 PageOne</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pc.newPage(PageOne.InitRaw());<br>    <span class="hljs-keyword">assert</span> pgno == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    pc.flushPage(pageOne);<br>&#125;<br><br><span class="hljs-comment">// 在打开已有文件时时读入 PageOne，并验证正确性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">loadCheckPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> PageOne.checkVc(pageOne);<br>&#125;<br></code></pre></td></tr></table></figure><p>DM层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的DataItem实现的，所以DataManager只需要提供<code>read()</code>和<code>insert()</code>方法。<br><code>read()</code>方法根据UID从缓存中获取DataItem，并检验其有效位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DataItem <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItemImpl</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> (DataItemImpl)<span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">if</span>(!di.isValid()) &#123;<br>        di.release();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> di;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert()</code>方法是在页面索引中获取一个足以存储插入内容的页面的页号，获取页面后首先要写入日志，然后才可以通过<code>pageX</code>插入数据，并返回插入位置的偏移。最后将页面信息重新插入页面索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);<br>    <span class="hljs-keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DataTooLargeException;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获取可用页</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>        pi = pIndex.select(raw.length);<br>        <span class="hljs-keyword">if</span> (pi != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newPgno</span> <span class="hljs-operator">=</span> pc.newPage(PageX.initRaw());<br>            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DatabaseBusyException;<br>    &#125;<br><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">freeSpace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pi.pgno);<br>        <span class="hljs-comment">// 首先做日志</span><br>        <span class="hljs-type">byte</span>[] log = Recover.insertLog(xid, pg, raw);<br>        logger.log(log);<br>        <span class="hljs-comment">// 再执行插入操作</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageX.insert(pg, raw);<br><br>        pg.release();<br>        <span class="hljs-keyword">return</span> Types.addressToUid(pi.pgno, offset);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 将取出的 pg 重新插入 pIndex</span><br>        <span class="hljs-keyword">if</span>(pg != <span class="hljs-literal">null</span>) &#123;<br>            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pIndex.add(pi.pgno, freeSpace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DataManager正常关闭时，需要执行缓存和日志的关闭流程，并且要设置第一页的字节校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.close();<br>    logger.close();<br><br>    PageOne.setVcClose(pageOne);<br>    pageOne.release();<br>    pc.close();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[DM模块的向上抽象：DataItem]]<br>[[DM模块的向下抽象]]<br>[[DM模块的页面索引]]<br>[[日志文件]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>版本管理</title>
    <link href="/2025-06-16/4d9e5841edc0/"/>
    <url>/2025-06-16/4d9e5841edc0/</url>
    
    <content type="html"><![CDATA[<p>DM是MYDB的数据管理核心，VM是MYDB的事务和数据版本的管理核心。VM基于两段锁协议（2PL）实现了可串行的调度序列，并实现了MVCC以消除读写阻塞，同时实现了两种隔离级别。</p><h1 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h1><p>严格两段锁协议会阻塞事务，直到持有锁的线程将其释放。如果处理不当会出现不同事务之间的死锁问题。为了检测死锁，可将这种等待释放锁的关系抽象为有向边，当事务Ti在等待Tj释放锁时，可以表示为<code>Ti-&gt;Tj</code>。这样锁的依赖关系可以标识为一个图。检测死锁则只需要查看该图中是否存在环即可。<br>MYDB使用一个<code>LockTable</code>对象在内存中维护这个有向图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTable</span> &#123;<br><span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u; <span class="hljs-comment">// 某个事务已获得的资源列表</span><br><span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; u2x; <span class="hljs-comment">// 资源被所关联的事务持有的关系列表</span><br><span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="hljs-comment">// 正在等待某个资源的事务列表</span><br><span class="hljs-keyword">private</span> Map&lt;Long, Lock&gt; waitLock; <span class="hljs-comment">// 正在等待资源的事务锁</span><br><span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; waitU; <span class="hljs-comment">// 事务正在等待的资源</span><br><span class="hljs-keyword">private</span> Lock lock;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在每次出现等待情况时，就尝试向图中添加一条边并进行死锁检测，如果检测到死锁，就撤销这条边，同时撤销该事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不需要等待则返回null, 否则返回锁对象</span><br><span class="hljs-comment">// 会造成死锁则抛出异常</span><br><span class="hljs-keyword">public</span> Lock <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(isInList(x2u, xid, uid)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (!u2x.containsKey(uid)) &#123;<br>u2x.put(uid, xid);<br>putIntoList(x2u, xid, uid);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>waitU.put(xid, uid);<br>putIntoList(wait, xid, uid);<br><span class="hljs-keyword">if</span>(hasDeadLock()) &#123;<br>waitU.remove(xid);<br>removeFromList(wait, uid, xid);<br><span class="hljs-keyword">throw</span> Error.DeadlockException;<br>&#125;<br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>l.lock();<br>waitLock.put(xid, l);<br><span class="hljs-keyword">return</span> l;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用<code>add()</code>方法后如果需要等待则会返回一个上了锁的Lock对象。调用方在获取该对象时，需要尝试获取该独享的锁，由此实现阻塞线程的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lt.add(xid, uid);<br><span class="hljs-keyword">if</span> (l != <span class="hljs-literal">null</span>) &#123;<br>l.lock(); <span class="hljs-comment">// 会阻塞在这一步</span><br>l.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找图中是否有环的算法是一个深度优先算法，只是需要注意该图未必是联通图。思路就是为每个节点设置一个初始化为-1的访问位，随后遍历所有节点，以每个非-1的节点作为根节点深度搜索，并将深搜该图中遇到的所有节点都设置为同一个数字，不同连通图的数字不同。这样在遍历某个图时如果遇到了之前遍历过的节点，说明出现了环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDeadLock</span><span class="hljs-params">()</span> &#123;<br>    xidStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    stamp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> xid : x2u.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-literal">null</span> &amp;&amp; s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        stamp ++;<br>        <span class="hljs-keyword">if</span>(dfs(xid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stp</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp == stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp &lt; stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    xidStamp.put(xid, stamp);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> waitU.get(xid);<br>    <span class="hljs-keyword">if</span>(uid == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u2x.get(uid);<br>    <span class="hljs-keyword">assert</span> x != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dfs(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个事务提交或被撤销时，就可以释放它持有的所有锁，并将自己从等待图中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        List&lt;Long&gt; l = x2u.get(xid);<br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>                selectNewXID(uid);<br>            &#125;<br>        &#125;<br>        waitU.remove(xid);<br>        x2u.remove(xid);<br>        waitLock.remove(xid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while循环释放掉一个线程的所有资源锁，这些资源将被等待的线程获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从等待队列中选择一个 xid 来占用 uid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNewXID</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> &#123;<br>    u2x.remove(uid);<br>    List&lt;Long&gt; l = wait.get(uid);<br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">assert</span> l.size() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(!waitLock.containsKey(xid)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            u2x.put(uid, xid);<br>            <span class="hljs-type">Lock</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> waitLock.remove(xid);<br>            waitU.remove(xid);<br>            lo.unlock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l.size() == <span class="hljs-number">0</span>) wait.remove(uid);<br>&#125;<br></code></pre></td></tr></table></figure><p>解锁时将该Lock对象unlock即可，这样业务线程就获取到了锁，可以继续执行了。</p><h1 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h1><p>VM层通过<code>VersionManager</code>接口向上层提供功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VersionManager</span> &#123;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时VM的实现类还被设计为Entry的缓存区，需要继承<code>AbstractCache&lt;Entry&gt;</code>，需要实现获取到缓存和从缓存释放的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Entry <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.loadEntry(<span class="hljs-built_in">this</span>, uid);<br>    <span class="hljs-keyword">if</span>(entry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.NullEntryException;<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Entry entry)</span> &#123;<br>    entry.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>begin()</code>用于开启一个事务，初始化事务的解雇，并将其存放在<code>activeTransaction</code>中，用于检查与快照：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tm.begin();<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Transaction.newTransaction(xid. level, activeTransaction);<br>activeTransaction.put(xid, t);<br><span class="hljs-keyword">return</span> xid;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commit()</code>用于提交一个事务，主要用于释放相关的结构和事务持有的锁，同时修改TM状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>lock.lock();<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>lock.unlock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (t.err != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> t.err;<br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException n) &#123;<br>System.out.println(xid);<br>System.out.println(activeTransaction.keySet());<br>Panic.panic(n);<br>&#125;<br>lock.lock();<br>activeTransaction.remove(xid);<br>lock.unlock();<br>lt.remove(xid);<br>tm.commit(xid);<br>&#125;<br></code></pre></td></tr></table></figure><p>撤销事务的方法有手动与自动两种，手动值调用<code>abort()</code>方法，自动则是在事务被检测出死锁或出现版本跳跃时，会自动撤销回滚事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internAbort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">boolean</span> autoAborted)</span> &#123;<br>lock.lock();<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br><span class="hljs-keyword">if</span> (autoAborted) activeTransaction.remove(xid);<br>lock.unlock();<br><span class="hljs-keyword">if</span> (t.autoAborted) <span class="hljs-keyword">return</span>;<br>lt.remove(xid);<br>tm.abort(xid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>read()</code>方法读取一个Entry，需要判断版本可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>publci <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception &#123;<br>lock.lock();<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>lock.unlock();<br><span class="hljs-keyword">if</span> (t.err != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throws</span> t.err;<br><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (Visibility.isVisible(tm, t, entry)) <span class="hljs-keyword">return</span> entry.data();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>entry.release();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert()</code>方法则是将数据包裹为Entry，然后交给DM插入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>lock.lock();<br><span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>lock.unlock();<br><span class="hljs-keyword">if</span> (t.err != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> t.err;<br><span class="hljs-type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);<br><span class="hljs-keyword">return</span> dm.insert(xid, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delete()</code>方法则较为复杂，实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置<code>XMAX</code>。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>lock.lock();<br><span class="hljs-type">Transactoin</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>lock.unlock();<br><br><span class="hljs-keyword">if</span> (t.err != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> t.err;<br><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!Visibility.isVisible(tm, t, entry)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>l = lt.add(xid, uid);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>t.err = Error.ConcurrentUpdateException;<br>internAbort(xid, <span class="hljs-literal">true</span>);<br>t.autoAborted = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">throw</span> t.err;<br>&#125;<br><span class="hljs-keyword">if</span> (l != <span class="hljs-literal">null</span>) &#123;<br>l.lock();<br>l.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (Visibility.isVersionSkip(tm, t, entry)) &#123;<br>t.err = Error.ConcurrentUpdateException;<br>internAbort(xid, <span class="hljs-literal">true</span>);<br>t.autoAborted = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">throw</span> t.err;<br>&#125;<br>entry.setXmax(xid);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>entry.release();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[事务的隔离级别]]<br>[[2PL与MVCC]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事务管理</title>
    <link href="/2025-06-16/c99cdb001933/"/>
    <url>/2025-06-16/c99cdb001933/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如项目结构所说，事务管理(Transaction Manager)通过维护<code>.xid</code>文件来维护事务状态，并提供接口供其他模块查询事务状态。<br>在MYDB中，每个事务都有一个XID作为唯一标识。事务的XID从1标号，随事务数目自增，不可重复。我们规定<code>XID 0</code>是一个超级事务，当一些操作想在没有申请事务的情况下进行时，可以将操作的XID设为0。<code>XID 0</code>的事务状态永远是<code>committed</code>。<br>在MYDB中，每个事务都分为三种状态：</p><ul><li><code>active</code>：正在进行，尚未结束</li><li><code>committed</code>：已提交</li><li><code>aborted</code>：已撤销回滚<br><code>.xid</code>文件给每个事务分配了1字节的空间用于保存其状态。同时在每个<code>.xid</code>文件头部，还保存了一个8字节的数字，记录该<code>.xid</code>文件管理事务的数目。因此事务的XID在文件中会存储在<code>(xid-1)+8</code>字节处，<code>xid-1</code>是因为<code>XID 0</code>的事务状态不需要记录。<br>事务管理Manager类提供了诸如开启新事务、修改&#x2F;查询事务状态、关闭TM等接口供其他模块使用。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>文件读写采用了NIO方式的<code>FileChannel</code>，读写方式与传统IO的<code>Input/Output Stream</code>的接口有所区别。<br>在构造函数创建一个事务管理器后，首先要对<code>.xid</code>文件进行校验以保证其合法。校验方式是通过文件头的8字节数字反推文件的理论长度，与文件的实际长度做对比，不同则认为该<code>.xid</code>文件不合法。 对于校验未通过的情况（无法恢复的错误），会直接通过<code>panic</code>方法强制停机。<br>在开始一个事务时，首先要设置对应事务位置字节的状态为<code>committed</code>，然后标识位自增，还需要更新文件头。<br>事务管理中的所有文件操作在执行后都需要立刻刷入磁盘，防止崩溃后文件丢失数据，这通过<code>fileChannel</code>的<code>force()</code>方法强制同步缓存内容至文件中，类似BIO的<code>flush()</code>方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目结构</title>
    <link href="/2025-06-16/fa00f1b5e0ef/"/>
    <url>/2025-06-16/fa00f1b5e0ef/</url>
    
    <content type="html"><![CDATA[<p>本项目照抄自[MYDB](<a href="https://cn-guoziyang.github.io/article/mydb0.html">一起写个数据库 —— 0. 项目结构和一些不得不说的话 - MYDB - 项目 - 计算机 | ziyang balabala~ &#x3D; 菜狗の日常</a>).整体分为<a href="%E5%8F%8C%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99">后端和前端</a>，之间通过<code>socket</code>进行交互。<br>前端即客户端职责单一，读取用户输入并发送倒后端执行，输出返回结果后等待下一次输入。后端需要解析SQL语句，识别合法语句后就尝试执行并返回结果。<br>不包括SQL语句解析器，MYDB后端分为五个模块，每个模块之间通过接口向其依赖的模块提供方法：</p><ul><li>[[事务管理]](Transaction Manager, TM）：通过维护<code>.xid</code>文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态。</li><li>[[数据管理]](Data Manager, DM)：直接管理数据库<code>.db</code>文件和<code>.log</code>日志文件，主要有以下职责：<ol><li>分数据页管理DB文件并进行缓存</li><li>管理日志文件，保证出错时可根据日志进行恢复</li><li>抽象DB文件为<code>DataItem</code>类供上层模块使用，并提供缓存</li></ol></li><li>[[版本管理]](Version Manager, VM)：通过两端锁协议实现可串行的调度序列，并实现MVCC以消除读写堵塞，并实现两种隔离级别。</li><li>[[索引管理]](Index Manager, IM)：实现基于B+树的索引。<code>where</code>子句仅支持已索引字段。</li><li>[[字段和表管理]](Table Manager, TBM)：实现对字段和表的管理，同时解析SQL语句，根据语句内容对表进行操作。</li></ul><h3 id="先总结一下各个模块提供的操作"><a href="#先总结一下各个模块提供的操作" class="headerlink" title="先总结一下各个模块提供的操作,"></a>先总结一下各个模块提供的操作,</h3><ul><li>DM: <code>insert(x), update(x), read(x)</code><br>  DM提供了针对数据项(DataItem)的基本插入, 更新, 读取操作, 且这些操作是原子性的. DM会直接对数据库文件进行读写.</li><li>TM: <code>begin, commit(T), abort(T), isActive(T),isCommitted(T),isAborted(T)</code><br>  TM提供了针对事务的开始, 提交, 回滚操作, 同时提供了对数据项状态的查询操作.</li><li>VM: <code>insert(X), update(X), read(X), delete(X)</code><br>  VM提供了针对记录(entry)的增删查改操作, VM在内部为每条记录维护多个版本, 并根据不同的事务, 返回不同的版本. VM对这些实现, 是建立在DM和TM的各个操作上的，还有一个事务可见性类Visibility。</li><li>TBM: <code>execute(statement)</code><br>  TBM就是非常高层的模块了, 他能直接执行用户输入的语句(statement), 然后进行执行. TBM对语句的执行是建立在VM和IM提供的各个操作上的.</li><li>IM: <code>value search(key), insert(key, value)</code><br>  IM提供了对索引的基本操作.</li></ul><h3 id="read语句的流程"><a href="#read语句的流程" class="headerlink" title="read语句的流程"></a>read语句的流程</h3><p>假设现在要执行<code>read * from student where id = 2012141461290</code>, 并且在id上已经建有索引. 执行过程如下:</p><ol><li>TBM接受语句, 并进行解析.  </li><li>TBM调用IM的<code>search</code>方法, 查找对应记录所在的地址.  </li><li>TBM调用VM的<code>read</code>方法, 并将地址作为参数, 从VM中尝试读取记录内容.  </li><li>VM通过DM的<code>read</code>操作, 读取该条记录的最新版本.  </li><li>VM检测该版本是否对该事务可见, 其中需要<code>Visibility.isVisible()</code>方法.  </li><li>如果可见, 则返回该版本的数据.  </li><li>如果不可见, 则读取上一个版本, 并重复5, 6, 7.  </li><li>TBM取得记录的二进制内容后, 对其进行解析, 还原出记录内容.  </li><li>TBM将记录的内容返回给客户端.</li></ol><h3 id="insert语句的流程"><a href="#insert语句的流程" class="headerlink" title="insert语句的流程"></a>insert语句的流程</h3><p>假设现在要执行<code>insert into student values “zhangyuanjia” 2012141461290</code>这条语句. 执行过程如下:</p><ol><li>TBM接受语句, 并进行解析.  </li><li>TBM将<code>values</code>的值, 二进制化.  </li><li>TBM利用VM的<code>insert</code>操作, 将二进制化后的数据, 插入到数据库.  </li><li>VM为该条数据建立版本控制, 并利用DM的<code>insert</code>操作, 将数据插入到数据库.  </li><li>DM将数据插入到数据库, 并返回其被存储的地址.  </li><li>VM将得到的地址, 作为该条记录的handler, 返回给TBM.  </li><li>TBM计算该条语句的key, 并将handler作为data, 并调用IM的insert, 建立索引.  </li><li>IM利用DM提供的<code>read</code>和<code>insert</code>等操作, 将key和data存入索引中.  </li><li>TBM返回客户端插入成功的信息.</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库的完整性约束</title>
    <link href="/2025-05-24/8bfe73c3f5d2/"/>
    <url>/2025-05-24/8bfe73c3f5d2/</url>
    
    <content type="html"><![CDATA[<p>完整性约束是数据库中定义的规则，用于确保数据正确一致。<br>常见的完整性约束有：</p><ul><li>主键约束：确保表中主键列没有重复值。</li><li>外键约束：确保表中外键列的值在关联表中存在。</li><li>唯一约束：确保表中某一列或某几列组合不重复。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库 事务</title>
    <link href="/2025-05-24/04dea9bc7c86/"/>
    <url>/2025-05-24/04dea9bc7c86/</url>
    
    <content type="html"><![CDATA[<p>事务（Transaction）是一组相互依赖的数据库操作，这批操作要么全部成功，要么全部失败。事务的目的是确保数据库在多个操作过程中始终保持一致的状态，不允许中间状态暴露，即使在发生故障或错误的情况下。<br>一些需要事务的例子：</p><ul><li>从 A 账户扣钱、向 B 账户加钱，这两步必须同时成功或同时失败。如果没有事务，可能出现 “A 扣了钱但 B 没收到” 的情况。这两个操作会被打包为一个事务。</li><li>用户秒杀商品时，需检查库存是否充足→扣减库存→创建订单→生成支付记录。如果库存扣减后，订单创建失败，必须回滚库存，否则其他用户会看到 “虚假缺货”。</li><li>批量调整商品价格时，若先修改 100 条中的 50 条，此时被其他查询读到 “部分修改” 的价格，会导致业务错误。用事务包裹后，只有全部修改完成并提交，其他操作才能看到最终结果。</li><li>检查用户名→插入用户记录→赠送新手礼包（修改礼包表）。如果用户名校验通过、用户记录插入成功，但礼包赠送失败，必须回滚用户记录，避免 “有用户无礼包” 的不一致。</li></ul><h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>事务中的所有操作要么全部完成，要么全部不完成。如果事务中的任何一个操作失败，整个事务都会回滚到事务开始前的状态。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务必须确保数据库从一个一致的状态转换到另一个一致的状态。事务执行前后，数据库的完整性约束必须保持不变。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的执行是独立的，一个事务的中间状态对其他事务不可见，并发执行的事务之间不会相互干扰。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一旦事务提交，其对数据库的修改就是永久的，即使系统发生故障也不会丢失。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据存储：LSM树</title>
    <link href="/2025-05-21/648beb34b693/"/>
    <url>/2025-05-21/648beb34b693/</url>
    
    <content type="html"><![CDATA[<p>LSM（Log Structured Merge Tree）并非B+树或红黑树一样是严格的树状数据结构，它其实是一种基于日志结构的存储模型。LSM树的核心思想与特点是<strong>将写入操作优先写入内存中的日志结构，然后定期将内存中的数据合并到磁盘数据中</strong>，以此优化写入性能。<br>传统的存储系统中，当一条数据被更新时，通常会直接找到原来的数据位置并原地进行修改，该操作称为<em>随机写</em>，因为每次写入操作都可能发生在磁盘的不同位置，导致磁盘的读写头频繁移动，降低效率。<br>而LSM树在收到更新记录后，不会直接修改已有数据，而是将所有的数据操作记录（增删改）保存在内存当中作为日志文件（MemTable），当保存的操作达到一定量后再批量<em>顺序写入</em>到磁盘中。此时所有的写入操作都是追加到文件末尾，磁盘的读写头不需要频繁移动，效率更高。<br>但日志式写入不会修改已有的键值对，而是将新的键值对作为新记录追加到内存中，新旧记录会被同时写入磁盘，因此磁盘中可能包含重复的键值对记录，而最新的记录才是正确的。<br>这样设计虽然大大提高写入性能，但也出现新的问题：</p><ul><li>冗余存储。对于某个键值对，实际上只有最新的记录有用，其他无用记录仍旧战局内存空间，需要额外的Compact操作合并多个SSTable来清除冗余记录。</li><li>读取数据时需要从最新的记录倒序查询，直到找到某个key的记录，最坏情况下需要查询所有的SSTable。这里可以通过索引&#x2F;布隆过滤器来优化查找速度。</li></ul><h1 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h1><p>LSM树有三个重要组成部分：<br><strong>MemTable 内存表</strong><br>MemTable是在内存中的数据结构，用于保存最艰难更新的数据，会按照Key有序地组织这些数据。LSM树对于如何组织数据没有明确的数据结构定义。<br>数据以键值对形式插入MemTable中，插入时间复杂度为<code>O(log n)</code>或<code>O(1)</code>。<br>由于数据暂时保存在内存中，而内存并非可靠存储，断电时会丢失数据，因此通常会通过预写式日志的方式保证数据的可靠。<br><strong>Immutable MemTable</strong><br>当MemTable达到一定大小后会冻结为Immutable MemTable。这是MemTable变为SSTable的一个中间状态。写操作会创建一个新的MemTable处理，保证转存过程不阻塞数据更新操作。<br><strong>SSTable 排序字符串表</strong><br>是LSM树在磁盘中的数据结构。SSTable是一个不可变的有序键值对文件，写入磁盘后内容不会被修改。</p><h1 id="LSM的合并策略"><a href="#LSM的合并策略" class="headerlink" title="LSM的合并策略"></a>LSM的合并策略</h1><p>随着数据操作记录增多，SSTable中的数量会不断增长，其中冗余记录占比也会越大，因此需要合并SSTable。<br>LSM的合并策略基于三个重要概念上：</p><ul><li>读取放大：读取数据时实际的读取量大于真正的数据量。LSM树中，数据被分散存储在多个位置，包括MemTable和多个SSTable文件，读取数据需要依次在这些地方查找。并且因为可能的多版本相同键值对，实际读取的数据量会更大。</li><li>写入放大：写入数据时实际写入的数据量大于真正的数据量。写入新数据时可能触发合并操作，大量键值对会被重新写入新的SSTable，导致实际写入量远大于该键值对的数据量。</li><li>空间放大：数据实际占用的磁盘空间比数据的真实容量更多。对于一个键值对来说，只有最新的记录有效，之前的冗余记录都可以被回收。</li></ul><h2 id="大小分层策略"><a href="#大小分层策略" class="headerlink" title="大小分层策略"></a>大小分层策略</h2><p>大小分层（size-tiered）策略基于文件大小进行合并。它的核心思想是将SSTable按照大小分层，每一层的文件大小逐渐增加。当某一层文件数量达到阈值时触发合并操作，并移动到下一层。<br>该策略的写入性能较高，实现与维护相对简单。但由于数据可能分布在多个层级，会增加读取放大。<br>当层级达到一定数量时，最底层的单个SSTable大小会非常大，且即使对于同一层的SSTable，每个键值对的记录依然可能存在多份，只有达到阈值触发合并后才会消除这些冗余记录，因此会导致空间放大。 </p><h2 id="层次化合并"><a href="#层次化合并" class="headerlink" title="层次化合并"></a>层次化合并</h2><p>层次化合并（leveled-compaction）的核心思想是将SSTable分为多个层次，每个层次的文件大小和数量都有严格限制，且每一层的SSTable全局有序，即一个键值对在每一层至多仅有1条记录。合并操作会定期在各个层次之间进行，以保持层次结构的平衡，合并后的SSTable同样也会被写入到下一层。<br>层次化合并的步骤如下：</p><ol><li>当L 1的大小超过L 1容量时，会从L 1中选择至少一个SSTable，然后把它和L 2<strong>有交集的部分</strong>进行合并，生成的文件放在L 2.</li><li>如果L 2合并后的结果仍旧超出L 2的阈值大小，那么重复步骤1；多个不相干的合并可以并发执行。<br>这样的合并操作能让空间放大问题得到缓解，但写放大问题会更加突出：如果 Level N层某个SSTable的键值范围跨度很大，覆盖了Level N+1所有键值范围，那么合并时实际上会涉及N+1层的全部数据。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据存储：B+树</title>
    <link href="/2025-05-21/11b5c62cd067/"/>
    <url>/2025-05-21/11b5c62cd067/</url>
    
    <content type="html"><![CDATA[<p>B+树是一种<strong>多路平衡查找树</strong>，属于B树的一种变体。它的他主要特点是<strong>所有数据都存储在叶节点上</strong>，内部节点只存储键值作为索引。这种结构使得B+树在磁盘存储和检索数据时大大减少磁盘访问次数，非常高效。</p><h2 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h2><p>B+树的结构可分为两部分，内部节点和叶节点。<br><strong>内部节点</strong><br>内部节点只存储键值用于索引。每个键值对应一个指向子节点的指针。<br><strong>叶节点</strong><br>所有时机的数据都存储在叶节点上。叶节点中的键值是有序的，方便快速查找。<br>叶节点之间通过指针链接，形成一个双向链表，方便范围查询。<br>B+树是平衡的，所有叶节点的深度相同。</p><h2 id="对B-树进行操作"><a href="#对B-树进行操作" class="headerlink" title="对B+树进行操作"></a>对B+树进行操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找会从根节点开始，沿着内部节点索引逐步向下查找，直到找到叶节点。由于B+树平衡，因此查找时间复杂度为<code>O(logN)</code>，N为B+树中节点数目。<br><strong>查找步骤</strong></p><ol><li>查找总是从根节点开始。根节点是一个内部节点，存储若干键值与指针。</li><li>沿指针向下查找。在根节点中，找到第一个<code>&gt;=k</code>的键值<code>k_i</code>，然后沿着<code>k_i</code>对应的指针向下查找。重复上述步骤直至叶节点。</li><li>在叶节点中查找。到达叶节点后，在节点内顺序查找键值<code>k</code>。找到则返回对应值，未找到说明键值不存在。</li></ol><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>由于要保持所有叶节点同一深度（保持平衡），因此插入操作较为复杂，还可能需要调整之前的叶节点。<br><strong>插入步骤</strong><br>假设需要插入键值<code>k</code>与其对应值<code>v</code> ：</p><ol><li>查找插入位置。通过查找操作，找到键值<code>k</code>应该插入的叶节点。</li><li>插入键值。在叶节点中找到合适的位置插入键值<code>k</code>与<code>v</code>。</li><li>处理叶节点溢出。如果叶节点键值数量超过最大容量M，需要分裂叶节点。分裂后还需要更新内部节点的索引，确保树的结构仍然正确。</li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除与插入一样，在处理完键值对后，还需要重新整理其他节点保证B+树的平衡。<br><strong>删除步骤</strong><br>假设需要删除键值<code>k</code>：</p><ol><li>查找键值位置。首先通过查找操作找到<code>k</code>所在的叶节点。</li><li>删除键值。从叶节点中删除键值<code>k</code>和对应的值。</li><li>处理叶节点欠载。如果叶节点的键值数量少于最小容量（通常是最大容量的一般），需要进行合并或借键操作。处理之后也需要更新内部节点。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>K-V存储引擎</title>
    <link href="/2025-05-21/ebe5e43f14ae/"/>
    <url>/2025-05-21/ebe5e43f14ae/</url>
    
    <content type="html"><![CDATA[<p>K-V存储引擎是一种基于键值对的数据存储方式，是许多数据库存储系统的核心组件。K-V存储引擎中，数据以键和值的形式存储，键是唯一标识符，值是与键相关联的数据。<br>常见的K-V存储引擎有：</p><ul><li>Redis</li><li>Rocks DB</li><li>Level DB</li><li>Memcached</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库存储引擎</title>
    <link href="/2025-05-21/a354aa4b33c4/"/>
    <url>/2025-05-21/a354aa4b33c4/</url>
    
    <content type="html"><![CDATA[<p>是驱动数据库管理系统进行操作的核心，它封装了数据存储和管理的具体实现细节，用于实现数据的存储、检索、管理和维护等功能。简单来说，存储引擎就是指表的类型以及表在计算机上的存储方式。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。<br>存储引擎通常由以下几部分组成：</p><ol><li>数据存储模块：负责将数据以特定格式存储在磁盘或内存中。</li><li>索引管理模块：用于创建和维护索引，以提高数据检索的效率。</li><li>事务管理模块：支持事务操作，确保数据操作的原子性、一致性、隔离性和持久性。</li><li>并发控制模块：管理多个用户或进程对数据的并发访问，防止数据冲突不一致。</li><li>恢复模块：在系统故障或数据损坏时，通过日志、备份等方式恢复数据。</li></ol><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[数据存储：LSM树]]<br>[[数据存储：B+树]]<br>[[K-V存储引擎]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 查询的执行顺序</title>
    <link href="/2025-05-21/57de827b9f4b/"/>
    <url>/2025-05-21/57de827b9f4b/</url>
    
    <content type="html"><![CDATA[<p>将所有的查询语法集中到一次SQL执行中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-keyword">column</span>, agg_func(column_or_expression), ...<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">join</span> another_table<br><span class="hljs-keyword">on</span> mytable.column <span class="hljs-operator">=</span> another_table.column;<br><span class="hljs-keyword">where</span> constraint_expression<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span><br><span class="hljs-keyword">having</span> constraint_expression<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">asc</span><span class="hljs-operator">/</span><span class="hljs-keyword">desc</span>;<br>limit num_limit <span class="hljs-keyword">offset</span> num_offset;<br></code></pre></td></tr></table></figure><p>一次查询的执行总是先从数据中按条件筛选出新数据，然后对这些数据做一次计算整理，按要求返回为结果，并保证结果尽可能简单直接。<br><strong>执行顺序</strong></p><ol><li><code>from</code>与<code>joins</code>：用于确定一个整体的数据范围，可能会生成一个临时数据表用于下列过程。</li><li><code>where</code>：在数据源中按要求进行筛选，丢弃不符合要求的数据行。所有的筛选属性只能来自<code>from</code>圈定的表。<code>as</code>别名不能在该阶段使用，因为别名可能是一个尚未执行的表达式。</li><li><code>group by</code>：对之前的数据进行分组和统计，并将结果集缩小为分组数目。</li><li><code>having</code>：对分组完成后的结果集进行筛选。<code>as</code>别名同样不能在该阶段使用。</li><li><code>select</code>：对结果集简单筛选和计算。</li><li><code>distinct</code>：对<code>select</code>后的数据集排重。</li><li><code>order by</code>：在结果集确定后对结果做排序。可使用<code>as</code>别名。</li><li><code>limit / offset</code>：从排序结果中截取部分数据。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 查询时进行统计</title>
    <link href="/2025-05-21/05e9963b7a46/"/>
    <url>/2025-05-21/05e9963b7a46/</url>
    
    <content type="html"><![CDATA[<p>SQL默认支持一组统计表达式，可以完成诸如计数，求平均等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 对全部结果数据统计<br><span class="hljs-keyword">SELECT</span> AGG_FUNC(column_or_expression) <span class="hljs-keyword">AS</span> aggregate_description, … <br><span class="hljs-keyword">FROM</span> mytable <br><span class="hljs-keyword">WHERE</span> constraint_expression_<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">column</span>;<br></code></pre></td></tr></table></figure><p>如果不知名如何分组，统计函数将对查询结果的全部数据进行统计。<br><strong>常用的统计函数</strong></p><ul><li><code>count(*)</code>,<code>count(column)</code>：计数，前者统计数据行数，后者统计column中非空行数。</li><li><code>min(column)</code>：最小值的一行。</li><li><code>max(column)</code>：最大值的一行。</li><li><code>avg(column)</code>：所有行求平均。</li><li><code>sum(column)</code>：所有行求和。<br><strong>分组统计</strong><br><code>group by</code>分组语法可以按照某列对数据进行分组，例如<code>group by Year</code>会将数据按年份分组，相同年份的数据分在一组中。将统计函数与分组结合，那么统计结果就i是对分组内的数据进行统计了。分组后的数量有多少，就会返回多少行数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> agg_func(column_or_expression) <span class="hljs-keyword">as</span> aggregate_description, …<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> constraint_expression<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span>;<br></code></pre></td></tr></table></figure>数据库会先对处理<code>where</code>子句，然后对结果做分组，如果要对分组后的数据再做筛选，则可以使用<code>having</code>语句解决该问题。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> agg_func(column_or_expression) <span class="hljs-keyword">as</span> aggregate_description, …<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> constraint_expression<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span><br><span class="hljs-keyword">having</span> group_condition;<br></code></pre></td></tr></table></figure><code>having</code>与<code>where</code>语法效果相同，只不过作用的结果集不同。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 查询时使用表达式</title>
    <link href="/2025-05-21/7c6a558230b9/"/>
    <url>/2025-05-21/7c6a558230b9/</url>
    
    <content type="html"><![CDATA[<p>使用SQL查询属性名时，实际上都可以用表达式来对指定属性进行一定的计算处理，以下是个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> speed <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span> <span class="hljs-keyword">as</span> half_speed <br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> <span class="hljs-built_in">abs</span>(position) <span class="hljs-operator">*</span> <span class="hljs-number">10</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>每种数据库都有自己的一套函数，包含常用的数字、字符串、时间等处理过程。<br>当进行属性计算时，还可以使用<code>as</code>关键字为表达式结果取别名（如上文的half_speed）。不只是表达式结果，普通属性列或者表格都可以取别名，让SQL易于理解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL NULLs</title>
    <link href="/2025-05-21/5d4dc2077e8b/"/>
    <url>/2025-05-21/5d4dc2077e8b/</url>
    
    <content type="html"><![CDATA[<p><code>null</code>代表没有数据。在编写SQL时需要考虑某个属性列为空的情况，导致编写复杂，所以若无必要，应尽量减少<code>null</code>的使用，减少数据中出现<code>null</code>的情啊坤哥。<br>常见的方式是为字段设置默认值。但一些数字默认值会让计算平均时出现差错（例如默认值为0的行仍会参与计算，<code>null</code>则不参与运算）。<br>多表查询有数据差异时必须用<code>null</code>填充，此时可以用<code>is (not) null</code>的限制条件选定某个字段是否为<code>null</code>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库范式</title>
    <link href="/2025-05-21/6c7d59766b59/"/>
    <url>/2025-05-21/6c7d59766b59/</url>
    
    <content type="html"><![CDATA[<p>范式是指数据表设计的规范，在范式规范下，数据库中每个表存储的重复数据能降到最少，有助于数据的一致性维护，能够降低不同表之间的数据耦合，保证独立增长。但过度规范化可能导致查询性能下降，因为需要频繁地进行表链接操作，也会增加数据库设计的复杂性。<br><strong>第一范式</strong> 1 NF<br>每个表的每一列都是不可再分的原子数据项，即表中的每个字段都不可分解。它要求每个字段的值必须单一，不能包含一组值。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> NAME </span>|<span class="hljs-string">     CLASS    </span>|<br>1  |<span class="hljs-string"> Ted  </span>|<span class="hljs-string"> math, English</span>|<br></code></pre></td></tr></table></figure><p>上述的CLASS字段包含多个值，不符合1 NF，修改为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> NAME </span>|<span class="hljs-string">  CLASS </span>|<br>1  |<span class="hljs-string"> Ted  </span>|<span class="hljs-string">  math  </span>|<br>1  |<span class="hljs-string"> Ted  </span>|<span class="hljs-string"> English</span>|<br></code></pre></td></tr></table></figure><p><strong>第二范式 2 NF</strong><br>满足1 NF的基础上，非主属性必须完全依赖于主键，而不是主键的一部分，即消除部分依赖。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> TYPE </span>|<span class="hljs-string"> NAME </span>|<span class="hljs-string"> COUNT </span>|<br>1  |<span class="hljs-string"> 101  </span>|<span class="hljs-string"> tabA </span>|<span class="hljs-string">   1   </span>|<br>1  |<span class="hljs-string"> 102  </span>|<span class="hljs-string"> tabB </span>|<span class="hljs-string">   2   </span>|<br></code></pre></td></tr></table></figure><p>上述的NAME字段仅依赖于ID，而不是整个主键（ID + TYPE），因此不符合2 NF，拆分为两个表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> TYPE </span>|<span class="hljs-string"> COUNT </span>|<br>1  |<span class="hljs-string"> 101  </span>|<span class="hljs-string">   1   </span>|<br>1  |<span class="hljs-string"> 102  </span>|<span class="hljs-string">   2   </span>|<br><br>TYPE |<span class="hljs-string"> NAME </span>|<br>101  |<span class="hljs-string"> tabA </span>|<br>102  |<span class="hljs-string"> tabB </span>|<br></code></pre></td></tr></table></figure><p><strong>第三范式 3 NF</strong><br>满足2 NF的基础上，非主属性不能依赖于其他非主属性，即消除传递依赖。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> NAME </span>|<span class="hljs-string"> CLASS </span>|<span class="hljs-string"> MONITOR </span>|<br>1  |<span class="hljs-string"> tabA </span>|<span class="hljs-string"> 1 cla </span>|<span class="hljs-string">   LI    </span>|<br>2  |<span class="hljs-string"> tabB </span>|<span class="hljs-string"> 2 cla </span>|<span class="hljs-string">  WANG   </span>|<br></code></pre></td></tr></table></figure><p>上述的MONITOR字段依赖于CLASS，而CLASS依赖于ID，存在传递依赖，不符合3 NF，将其拆分为两个表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> NAME </span>|<span class="hljs-string"> CLASS </span>|<br>1  |<span class="hljs-string"> tabA </span>|<span class="hljs-string"> 1 cla </span>|<br>2  |<span class="hljs-string"> tabB </span>|<span class="hljs-string"> 2 cla </span>|<br><br>CLASS |<span class="hljs-string"> MONITOR </span>|<br>1 cla |<span class="hljs-string">   LI    </span>|<br>2 cla |<span class="hljs-string">  WANG   </span>|<br></code></pre></td></tr></table></figure><p><strong>BCNF</strong><br>在满足3 NF的基础上，任何非平凡的函数依赖的决定方必须是候选键。要求消除非平凡的函数依赖。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> TYPE </span>|<span class="hljs-string"> MONITOR </span>|<br>1  |<span class="hljs-string"> 101  </span>|<span class="hljs-string">  ZHANG  </span>|<br>2  |<span class="hljs-string"> 102  </span>|<span class="hljs-string">   LI    </span>|<br></code></pre></td></tr></table></figure><p>这里的MONITOR字段依赖于TYPE，但TYPE并非候选键，因此不符合，将其拆分为两个表：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ID |<span class="hljs-string"> TYPE </span>|<br>1  |<span class="hljs-string"> 101  </span>|<br>2  |<span class="hljs-string"> 102  </span>|<br><br>TYPE |<span class="hljs-string"> MONITOR </span>|<br> 101 |<span class="hljs-string">  ZHANG  </span>|<br> 102 |<span class="hljs-string">   LI    </span>|<br></code></pre></td></tr></table></figure><p><strong>4 NF</strong><br>在满足BCNF的基础上，消除多值依赖。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>未命名</title>
    <link href="/2025-05-20/372ca3673ef3/"/>
    <url>/2025-05-20/372ca3673ef3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 查询结果处理</title>
    <link href="/2025-05-20/b281d4a0b45e/"/>
    <url>/2025-05-20/b281d4a0b45e/</url>
    
    <content type="html"><![CDATA[<p><strong>distinct</strong><br>可以使用<code>distinct</code>关键字指定某个或某些列唯一返回，选出唯一的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-keyword">column</span>, another_column, ...<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>(s);<br></code></pre></td></tr></table></figure><p><code>distinct</code>会直接删除重复的行，之后的<code>GROUP BY</code>语句也会返回唯一的行，但可以对相同属性值的行做一些统计计算，例如求和等。<br><strong>结果排序</strong><br><code>order by [col_name]</code>语句可让结果按多个属性列进行升序（ASC）或降序（DESC）排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">column</span>, another_column, ....<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>(s)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p><strong>通过<code>limit</code>选取部分结果</strong><br><code>limit</code>与<code>offset</code>子句常与<code>order by</code>语句一起使用，当整个结果排序后，可以用<code>limit</code>指定只返回多少行结果，用<code>offset</code>指定从哪一行开始返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">column</span>, another_column, ...<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>(s)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">ASC</span><span class="hljs-operator">/</span><span class="hljs-keyword">DESC</span><br>limit num_limit <span class="hljs-keyword">offset</span> num_offset;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 条件查询</title>
    <link href="/2025-05-20/bedaade6a103/"/>
    <url>/2025-05-20/bedaade6a103/</url>
    
    <content type="html"><![CDATA[<p>使用<code>select</code>查询的<code>where</code>子句可用来描述哪些行应当进入结果，通过condition限定条件筛选行数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">column</span>, another_column, ...<br><span class="hljs-keyword">from</span> mytable<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span><br><span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-keyword">or</span> another_condition<br><span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-keyword">or</span> ...;<br></code></pre></td></tr></table></figure><p>可通过<code>AND</code>或<code>OR</code>两个关键字组装多个条件。存在一些筛选整数&#x2F;浮点数的语法规则：</p><ul><li><code>=, !=, &lt;, &lt;=, &gt;, &gt;=</code></li><li><code>(NOT) BETWEEN ... AND ...</code></li><li><code>(NOT) IN (&quot;1&quot;,&quot;2&quot;,...)</code>：是否存在列表中<br>因为条件会在返回前筛选不必要的结果，SQL的运行速度会快很多。<br>其余的限定关键字有：</li><li><code>=</code>：完全等于</li><li><code>!=</code> <code>&lt;&gt;</code>：不等于</li><li><code>(NOT) LIKE</code>：支持通配符的<code>=</code> <code>!=</code></li><li><code>%</code>：通配符，匹配0个或以上的字符</li><li><code>-</code>：通配符，匹配1个字符</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL SELECT</title>
    <link href="/2025-05-20/00fb233d6433/"/>
    <url>/2025-05-20/00fb233d6433/</url>
    
    <content type="html"><![CDATA[<p>用于查询数据库中信息的查询语句。一条<code>select</code>语句允许我们指定从什么表取数据，取哪些数据，返回前对数据作何计算处理。<br>最常见的查询就是取出表中<em>所有数据</em>的某几列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">column</span>, another_column, ... <span class="hljs-keyword">from</span> mytable;<br></code></pre></td></tr></table></figure><p>查询结果是一个二维表格。像取出所有列的数据时，可以使用<code>*</code>代表所有列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mytable;<br></code></pre></td></tr></table></figure><h1 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h1><p>[[SQL 条件查询]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关系型数据库</title>
    <link href="/2025-05-20/a200538ae264/"/>
    <url>/2025-05-20/a200538ae264/</url>
    
    <content type="html"><![CDATA[<p>关系型数据库（Relational Database）是一种基于关系模型的数据库管理系统。它使用表格（Table）组织和存储数据，每个表格由行（Row）和列（Column）组成。<br>关系型数据库的核心思想是通过表格之间的关系来表示数据的关联。<br>关系模型的特点有：</p><ul><li>结构简单：数据以表格形式存储，易于理解和操作。</li><li>数据独立：数据的逻辑结构与物理存储分离，用户可以独立操作数据。</li><li>数据完整：通过主键和外键等约束机制，确保数据的完整和一致。</li><li>数据共享：多个用户可以共享同一份数据。<br>关系型数据库则指出较大复杂的查询操作，并且支持事务操作，保证数据操作的原子性、一致性、隔离性和持久性。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 多表联合查询</title>
    <link href="/2025-05-20/ac5d95ffaf7b/"/>
    <url>/2025-05-20/ac5d95ffaf7b/</url>
    
    <content type="html"><![CDATA[<p>当一个实体的属性数据被分散到多个数据表中时，就需要通过<code>join</code>整合不同表的数据来找到需要的数据。<br><strong>join</strong><br>关系数据表中都会又一个属性列设置为主键（primary key）用于唯一标识一体哦啊数据，不会重复，如同每个人的身份证号。最常见的主键就是自增ID，不重复的字符串&#x2F;哈希值也可以设为主键。<br>我们可以通过主键把两个表中具有相同主键的数据合并为新的行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">column</span>, another_column, ...<br><span class="hljs-keyword">from</span> mytable <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 主表<br>(<span class="hljs-keyword">inner</span><span class="hljs-operator">/</span><span class="hljs-keyword">left</span><span class="hljs-operator">/</span><span class="hljs-keyword">right</span><span class="hljs-operator">/</span><span class="hljs-keyword">full</span>) <span class="hljs-keyword">join</span> another_table <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 要链接的表<br><span class="hljs-keyword">on</span> mytable.id <span class="hljs-operator">=</span> another_table.id<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span>(s)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">column</span>, ... <span class="hljs-keyword">asc</span><span class="hljs-operator">/</span><span class="hljs-keyword">desc</span><br>limit num_limit <span class="hljs-keyword">offset</span> num_offset;<br></code></pre></td></tr></table></figure><p>通过<code>on</code>条件描述的关联关系里，<code>inner join</code>会取两个表中数据的交集，在交集中进行数据查询。<br><code>inner join</code>只会保留两个表的交集，会产生一定的数据丢失，而<code>left join</code>、<code>right join</code>、<code>full join</code>三个链接方式都会保留不能匹配的行。、<br>当<code>tableA join tableB</code>时，<code>left join</code>保留A的所有行，<code>right join</code>保留B的所有行，<code>full join</code>则不管是否匹配，同时保留A与B的所有行，如果某行在另一个表不存在，会用<code>NULL</code>填充数据。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2025-01-20/5277aaa9497e/"/>
    <url>/2025-01-20/5277aaa9497e/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h1><h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><p>C++程序的内存根据其进程结构高低，按照低位到高位分别是：</p><ul><li>代码区：存放可执行程序的机器码。</li><li>数据区：存放初始化的全局、静态变量和常量数据。</li><li>BSS（Block started by symbol）：存放未初始化的全局和静态变量。</li><li>堆：存放动态分配的内存。从低地址到高地址增长，容量大于栈。</li><li>栈：存放局部变量、函数、返回值等数据。从高地址向低地址增长，由编译器自动管理分配。</li></ul><h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><p>栈一般由硬件实现，CPU通过栈保存调用函数（子程序）时返回的地址，高级语言也使用栈作为局部变量的存储空间。<br>堆作为软件概念，使用与否完全由程序员显式地决定。<br>内存中，堆与栈共用全部的自由空间，但各自的起始地址与增长方向不同。如果内存过低，可能导致堆栈增长至相互覆盖，产生堆栈冲突。<br>二者的主要区别还有：</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论-拓扑排序</title>
    <link href="/2024-11-09/63c581909df4/"/>
    <url>/2024-11-09/63c581909df4/</url>
    
    <content type="html"><![CDATA[<h1 id="图论中的拓扑排序"><a href="#图论中的拓扑排序" class="headerlink" title="图论中的拓扑排序"></a>图论中的拓扑排序</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>拓扑排序是指将一个有向无环图(Directed Acyclic Graph, 简称DAG)进行排序，获得一个有序的线性序列的排序算法。</p><p>抽象来说，它将一个DAG拉长为一条包含所有节点的链条，并且不破坏DAG节点原本的先后顺序，即对于图中的每一条有向边<code>u -&gt; v</code>，在拉长后的链条中，都有节点<code>u</code>位于节点<code>v</code>之前。</p><p>拓扑排序可以用来确认节点发生的顺序，一个常用的简单例子是项目中的不同任务的次序安排：</p><p>一个项目中包含四个子任务A、B、C和D，且A依赖于B与D，C依赖于D，现在需要计算出A、B、C、D的执行顺序。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>拓扑排序的基本流程如下：</p><ul><li>构造一个队列Q和拓扑排序的结果队列T；</li><li>将所有没有依赖顶点的节点放入Q；</li><li>当Q中仍有节点时：<ul><li>从Q中取出一个顶点n并将其放入T；</li><li>对n的每一个邻接点m：<ul><li>去掉有向边<code>&lt;n, m&gt;</code>；</li><li>如果没有以m为终点的边，将m放入Q中；</li></ul></li></ul></li><li>重复上述步骤，直到队列Q为空。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>仿Minecraft程序化地形生成Demo制作心路</title>
    <link href="/2024-11-09/0e00a7cdf859/"/>
    <url>/2024-11-09/0e00a7cdf859/</url>
    
    <content type="html"><![CDATA[<h1 id="仿Minecraft程序化地形生成Demo-一点历程"><a href="#仿Minecraft程序化地形生成Demo-一点历程" class="headerlink" title="仿Minecraft程序化地形生成Demo - 一点历程"></a>仿Minecraft程序化地形生成Demo - 一点历程</h1><p>前段时间浏览编程大牛博客闲逛博客园时，偶然发现一位大佬使用Unreal引擎模拟MC地形生成流程。由于本人对MC有浓厚兴趣，也掌握一定UE引擎编程技能，同时希望通过该项目提高自己的UEC++项目经验，于是选用该系统作为项目主题构建Demo。<br>在收集资料以及参考他人项目源码时发现类似的Demo不在少数，然而自主实现的过程中依然碰上各类意想不到的困难阻碍，深感自身编程能力不足知识缺乏，遂写下心路历程浅记经验，同时罗列出参考的项目与教程为读者提供几分思路。</p><h2 id="从零开始了解地形生成"><a href="#从零开始了解地形生成" class="headerlink" title="从零开始了解地形生成"></a>从零开始了解地形生成</h2><p>对于Minecraft这样的沙盒游戏，其地形生成是游戏的核心功能，它要求在世界中创建大量的基本方块形成生动的地形。Minecraft的地形生成并非一次性全部加载与储存所有方块数据：</p><ul><li>从内存空间角度看， 储存整个世界的所有方块数据会占用大量的磁盘空间，而使用程序化生成只需要存储生成算法和少量的种子数据；</li><li>从加载时间看，玩家探索新区域时，程序化生成能即时生成地形，一次性生成则需要重新更新整个世界，方块放置与破坏也同样要储存整个数据集，严重延长加载时间。</li></ul><p>显然，游戏或和程序本身无法在每次创建世界时就直接包含整个世界的所有数据，而是只保存了“如何生成一个世界”的代码工具，即我们需要设计的地形生成算法。<br>为了保证玩家的游戏体验，一个合格的地形算法还需要让地形足够美观自然，让玩家体验到连贯、无缝的自然环境，而不是突兀不自然的地形变化。<br>这些地形生成的硬性需求告诉我们，一个程序化地形生成算法要有如下基本要求：</p><ul><li>可复现&#x2F;伪随机：在输入同一个种子时，算法计算出的地形（包括地形高度、生物群系和结构等）不随时间与硬件设备变动，保持不变。</li><li>连续性&#x2F;无断层：在分块加载和计算世界地形时，不同分块之间的地形在视觉上没有断层起伏，且分块的加载顺序对地形变化没有影响。</li></ul><p>以Minecraft为例，一个完整的世界生成可以拆分为如下部分：</p><ul><li>生物群系生成：通过不同的温湿度与其他数据确定不同位置属于哪种生物群系。MC当中，生物群系对地形的初始高度和地表结构都有影响，因此会最先生成。</li><li>高度生成：将生物群系、山地特征性等预先生成的参考值导入高度生成算法，决定世界的哪些部分属于陆地、哪些属于海洋、地形的起伏程度之类。这部分会将整个世界的基石构筑出来，包括山峦、峡谷、河道、海床、洞穴空腔和悬空地形等。</li><li>表面重载：对地形的表面进行覆写，根据生物群系和高度等信息决定地形表面应当是什么样子——草甸、雪山、沙漠、海洋以及地底的矿物生成等属于该步骤。</li><li>结构添加：为世界添加额外的新结构（树林、草丛、房屋结构、地牢等）。该步骤还会在高度生成前确定结构在区块内的范围。</li></ul><h2 id="实现过程摘抄"><a href="#实现过程摘抄" class="headerlink" title="实现过程摘抄"></a>实现过程摘抄</h2><p>在地形生成时使用了开源库<code>FastNoiseLite</code>作为噪声的生成辅助。<br>在UE内部选用地形展示时，一开始使用每个方块作为一个放置在世界中的实体Actor，但在简单生成时发现这样极其影响运行时间，于是选用每个区块生成一个Actor，同时使用动态生成网格体ProceduralMeshComponent来程序化生成区块面，减少渲染占用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://www.cnblogs.com/KillerAery/p/11509470.html">Minecraft类游戏地形生成机制 - KillerAery</a><br>[2] <a href="https://www.bilibili.com/BV13u411j7KX">[熟肉]Minecraft的地形是如何生成的？</a><br>[3] <a href="https://minecraft.fandom.com/zh/wiki/%E5%8C%BA%E5%9D%97">区块 - Minecraft Wiki</a><br>[4] <a href="https://minecraft.fandom.com/zh/wiki/%E7%94%9F%E7%89%A9%E7%BE%A4%E7%B3%BB#%E7%94%9F%E6%88%90">生物群系 - Minecraft Wiki</a><br>[5] <a href="https://zh.minecraft.wiki/w/%E4%B8%96%E7%95%8C%E7%94%9F%E6%88%90">世界生成 - Minecraft Wiki</a><br>[6] <a href="https://zh.minecraft.wiki/w/%E5%9C%B0%E7%89%A9">地物 - Minecraft Wiki</a><br>[7] <a href="https://www.bilibili.com/read/cv14958026/">创建自己的世界——Minecraft 1.18的地形生成</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>A*寻路算法</title>
    <link href="/2024-10-10/142c5063b9b6/"/>
    <url>/2024-10-10/142c5063b9b6/</url>
    
    <content type="html"><![CDATA[<h1 id="A-寻路"><a href="#A-寻路" class="headerlink" title="A*寻路"></a>A*寻路</h1><p>A*寻路有如下特点：</p><p><strong>基于网格</strong></p><p>A*寻路算法是基于格子的寻路算法，即算法会把地图看作多个格子组成，寻得的路径也是一连串相邻格子组成的路径。</p><p><strong>启发式</strong></p><p>对于一个网格，假设操作目标能四向移动，如何让程序知道往哪个格子走能更接近终点？如果能在每次移动前做一次评估，根据评估获得的值进行比较，取评估值最合适的格子进行移动，理论上就能达到这一目的。</p><p>这一思路被称为启发式，指通过评估找到合适的路径，即优先搜索最有可能产生最佳路径的格子。</p><h2 id="A-寻路的组成"><a href="#A-寻路的组成" class="headerlink" title="A*寻路的组成"></a>A*寻路的组成</h2><h3 id="估价-评估函数"><a href="#估价-评估函数" class="headerlink" title="估价&#x2F;评估函数"></a>估价&#x2F;评估函数</h3><p>先前提到算法需要对移动的方向进行评估获取估价值，因此需要编写一个估价函数进行计算。</p><p>对于任意一个格子 n，其估价计算函数为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">f</span>(n) = <span class="hljs-built_in">g</span>(n) + <span class="hljs-built_in">h</span>(n)<br></code></pre></td></tr></table></figure><p>g(n)指从起点到格子 n 的实际代价，h(n)是从格子 n 到终点的估计代价。</p><p><img src="/static/MaHpbKVMlokmwYxKGLScfSiynGb.png"></p><p>对于上述图片例子的三个格子，计算 f(n)值的流程是：</p><ul><li><p>格子 1：</p><ul><li>起点至格子 1 需移动 1 格，g(1) &#x3D; 1；</li><li>格子 1 到终点的直线距离为 6 格，h(1) &#x3D; 6；</li><li>f(1) &#x3D; 1 + 6 &#x3D; 7。</li></ul></li><li><p>同理得格子 2 的估价：f(2) &#x3D; g(2) + h(2) &#x3D; 1 + 4 &#x3D; 5</p></li><li><p>格子 3 的估价：f(3) &#x3D; g(3) + h(3) &#x3D; √2 + √17</p></li></ul><p>因此优先考虑去往格子 2 的情况。</p><p>上述对 h(n)的计算采用了简单的直线距离计算（即使用欧几里得距离），h(n)的值永远 &lt;&#x3D;格子 n 到终点的最短实际距离。但这样计算时会出现大量的平方与开根号的计算，并且需要采用浮点数，性能差。因此根据实际情况往往使用的是曼哈顿距离或对角线 + 直线的距离。</p><p>曼哈顿距离简单来说是只允许水平垂直移动的最短距离，因此曼哈顿距离肯定 &gt;&#x3D;格子 n 到终点的最短实际距离。</p><p>另一种加快运算的方式是，假设两个格子之间的单位距离 L，然后直接认为对角线距离为 1.4L，从而避免浮点数和根号运算。</p><h4 id="h-n-的影响"><a href="#h-n-的影响" class="headerlink" title="h(n)的影响"></a>h(n)的影响</h4><p>总地来说：</p><ul><li>如果 h(n) &lt;&#x3D; n 到终点的实际距离，A*算法可以找到最短路径，但搜索的点数多，搜索范围大，效率低；</li><li>如果 h(n) &gt; n 到终点的实际距离，搜索的点数少，搜索范围小，效率高，但是得到的路径并不一定是最短的。</li><li>h(n) 越接近 n 到终点的实际距离，那么 A*算法越完美。（个人理解是如果用曼哈顿距离，那么只需要找到一条长度小于等于该距离的路径就算完成任务了。而使用对角线距离就要找到一条长度大于等于对角线距离且最短的路径才行。）</li><li>若 h(n)&#x3D;0，即 f(n)&#x3D;g(n)，A*算法就变为了 Dijkstra 算法（Dijstra 算法会毫无方向的向四周搜索）。</li><li>若 h(n) 远远大于 g(n) ，那么 f(n) 的值就主要取决于 h(n)，A*算法就演变成了广度优先遍历算法。</li></ul><p>因此在启发式寻路算法中，估价函数十分重要，尤其是其中的 h(n)部分。</p><h3 id="A-寻路流程"><a href="#A-寻路流程" class="headerlink" title="A*寻路流程"></a>A*寻路流程</h3><h4 id="简述版"><a href="#简述版" class="headerlink" title="简述版"></a>简述版</h4><ul><li><p>预备两个列表 openList 与 closeList 储存对应的地图格；</p></li><li><p>将起点格加入开启列表 openList 中；</p></li><li><p>重复以下流程：</p><ul><li>遍历 openList，寻找 openList 中 f(n)最小的结点，将其设置为当前处理结点；</li><li>将当前处理结点移动至 closeList；</li><li>对当前处理结点的每个相邻结点：<ul><li>若其不可达或已在 closeList 中，将其忽略；</li><li>若其不在 openList 中，将其加入 openList，把当前处理结点设置为其父结点，并记录当前处理结点的 F、G 和 H 值；</li><li>若其已在 openList 中，检查当前处理结点到其的路径是否更好：依据计算出的 G 值进行参考，更小的 G 值表示更好的路径；若如此，将其父节点设置为当前处理结点，并重新计算其 G 值与 F 值，并可能需要对 openList 重新排序；</li></ul></li></ul></li><li><p>停止，当：</p><ul><li>终点被加入到 openList 中，此时找到了路径；</li><li>查找终点失败，并且 openList 为空，此时没有路径；</li></ul></li><li><p>保存路径，从终点开始，每个结点沿着其父结点移动至起点。</p></li></ul><h4 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h4><p>由于 A*寻路算法的核心为其估价函数，因此需要一个结构&#x2F;类储存如下信息：对象对应的网格 ID、该网格的 F、G、H 值及其父结点。以下是伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> id, Node* parent, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> h)<br>        : <span class="hljs-built_in">Id</span>(id), <span class="hljs-built_in">Parent</span>(parent), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h) &#123;<br>            f = <span class="hljs-built_in">calF</span>(g, h); <span class="hljs-comment">//构造函数内部的估价函数</span><br>    &#125;<br>    <span class="hljs-type">int</span> Id;<br>    Node* Parent;<br>    <br>    <span class="hljs-comment">//</span><br>    <span class="hljs-type">int</span> g;    <span class="hljs-comment">// 父节点到该网格的实际距离</span><br>    <span class="hljs-type">int</span> h;    <span class="hljs-comment">// 该网格至终点的估计距离 / 估计值</span><br>    <span class="hljs-type">int</span> f;    <span class="hljs-comment">// 该网格的总估价值</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">calF</span><span class="hljs-params">(<span class="hljs-type">int</span> g, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-comment">// 实现估价函数计算</span><br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要两个数据结构 openList 与 closeList 储存格子，前者储存将要被计算估值的格子，后者储存已经被计算估值的格子。</p><h2 id="改进-A-寻路"><a href="#改进-A-寻路" class="headerlink" title="改进 A*寻路"></a>改进 A*寻路</h2><h3 id="改进估价函数"><a href="#改进估价函数" class="headerlink" title="改进估价函数"></a>改进估价函数</h3><h4 id="选择预估函数"><a href="#选择预估函数" class="headerlink" title="选择预估函数"></a>选择预估函数</h4><h4 id="为函数增加权重"><a href="#为函数增加权重" class="headerlink" title="为函数增加权重"></a>为函数增加权重</h4><h4 id="结点比较时的优化"><a href="#结点比较时的优化" class="headerlink" title="结点比较时的优化"></a>结点比较时的优化</h4><h3 id="优化搜索邻域"><a href="#优化搜索邻域" class="headerlink" title="优化搜索邻域"></a>优化搜索邻域</h3><h3 id="使用双向搜索"><a href="#使用双向搜索" class="headerlink" title="使用双向搜索"></a>使用双向搜索</h3><h3 id="优化数据结构"><a href="#优化数据结构" class="headerlink" title="优化数据结构"></a>优化数据结构</h3><p>显然在算法逻辑中需要对 openList 与 closeList 进行频繁的增删和查询；</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>右值引用浅析</title>
    <link href="/2024-10-10/b27fcb36e098/"/>
    <url>/2024-10-10/b27fcb36e098/</url>
    
    <content type="html"><![CDATA[<h1 id="【C-11】右值引用解析"><a href="#【C-11】右值引用解析" class="headerlink" title="【C++11】右值引用解析"></a>【C++11】右值引用解析</h1><p>参考并翻译自 <a href="http://thbecker.net/articles/rvalue_references/section_01.html">Thoma’s Becker’s overview</a>（2013）。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>右值与右值引用是在 c++11 中新增的特性。在首次了解右值引用时很难看出设计这一特性的目的、解决了什么问题等，因此下文通过罗列编程中产生的（推动 C++ 设计右值引用的）问题，了解右值引用是怎么解决它们的。</p><p>右值引用解决了至少两个问题：</p><ul><li>移动语义</li><li>完美转发</li></ul><p>首先是移动语义。在描述这一问题前，需要先了解 C++ 中的左值与右值。</p><p>C 语言中对左值右值一开始的定义是：左值指能出现在赋值运算符左侧或右侧的表达式，右值则是只能出现在赋值运算符的右侧的表达式。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">42</span>；<br><span class="hljs-type">int</span> b = <span class="hljs-number">43</span>; <span class="hljs-comment">// a与b都是左值表达式</span><br>a = b;      <span class="hljs-comment">// ok</span><br>b = a;      <span class="hljs-comment">// ok</span><br>a = a * b;  <span class="hljs-comment">// ok</span><br><span class="hljs-comment">// a * b是右值表达式</span><br><span class="hljs-type">int</span> c = a * b; <span class="hljs-comment">// ok</span><br>a * b = <span class="hljs-number">42</span>;    <span class="hljs-comment">// error，右值表达式不能位于赋值运算符左侧</span><br></code></pre></td></tr></table></figure><p>C++ 在一开始时也同样沿用了这一定义，但在 C++ 中使用用户自定义类型并对其进行修改和赋值时，可能会出现一些微妙地不符合该定义的情况。</p><p>下述是一个可选的对左值右值的定义；这个定义依旧有不准确之处，但足够帮助你理解 C++ 的右值引用：</p><p>C++ 中，所有表达式不是左值表达式就是右值表达式；当一个表达式是左值表达式时，它对应着内存中的某个地址，并且允许我们通过&amp;操作符获得它的地址；而不是左值表达式的表达式都是右值表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>i = <span class="hljs-number">43</span>;             <span class="hljs-comment">// i为左值表达式</span><br><span class="hljs-type">int</span>* p = &amp;i;        <span class="hljs-comment">// ok, i为左值表达式，可取地址</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">foo</span>() = <span class="hljs-number">42</span>;         <span class="hljs-comment">// ok, foo() 也为左值表达式</span><br><span class="hljs-type">int</span>* p1 = &amp;<span class="hljs-built_in">foo</span>();   <span class="hljs-comment">// ok, 能够对foo()取地址</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foobar</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>j = <span class="hljs-built_in">foobar</span>();       <span class="hljs-comment">// ok, foobar()为右值表达式</span><br><span class="hljs-type">int</span>* p2 = &amp;<span class="hljs-built_in">foobar</span>();<span class="hljs-comment">// error, 不能对右值表达式取地址</span><br>j = <span class="hljs-number">42</span>;             <span class="hljs-comment">// ok, 42是一个右值表达式</span><br></code></pre></td></tr></table></figure><h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>假设 X 是一个类，它持有指向某种资源的指针或句柄，比如 m_pResource（这里的资源指任何需要花费大量努力去构造、克隆或销毁的东西）；一个很好的例子是 std::vector，它持有一系列对象，这些对象存在于分配的内存数组中。</p><p>与拷贝构造函数类似，假设 X 在代码中被这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>X x;<br><span class="hljs-comment">// 对x的部分操作和使用</span><br>x = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>对于最后一行代码，程序执行如下操作：</p><ul><li>克隆由 foo 返回的临时变量及其资源；</li><li>销毁 x 持有的资源，并使用克隆的变量替换它；</li><li>销毁 foo 返回的临时资源从而将其释放。</li></ul><p>可以得到一般的拷贝运算符的执行方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X <span class="hljs-type">const</span>&amp; rhs) &#123;<br>  <span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 对rhs.m_pResource指向的资源创建一次拷贝</span><br>  <span class="hljs-comment">// Destruct the resource that m_pResource refers to. </span><br>  <span class="hljs-comment">// Attach the clone to m_pResource.</span><br>  <span class="hljs-comment">// [...]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述步骤，程序出现了一次拷贝：对 foo()的返回值拷贝了一次临时变量，而后又将这一临时变量销毁。显然，存在一个更有效率的执行方式：交换 x 与 foo 返回的临时变量之间的资源指针，然后让临时变量的析构函数销毁 x 的原始资源。换句话说，当赋值运算符右侧是右值时，我们希望拷贝赋值运算符应该这么执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 交换 m-pResource 与 rhs.m_pResource</span><br>  <span class="hljs-comment">// [...]</span><br></code></pre></td></tr></table></figure><p>这就是 C++11 引入的_移动语义_。在 C++11 中，使用以下重载可以重载到移动语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(&lt;待定类型&gt; rhs) &#123;<br>  <span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 交换 m-pResource 与 rhs.m_pResource</span><br>  <span class="hljs-comment">// [...]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们在重载一个拷贝赋值运算符，因此这个“待定类型”必须是引用类型：我们希望 rhs 参数是按引用传递的；同时，我们希望这个“待定类型”能做到这个操作：</p><ul><li>使用左值表达式作为参数时，程序会调用正常版的拷贝（使用 const type &amp;类型）；使用右值表达式作为参数时，程序调用移动语义重载后的拷贝（使用待定类型）。</li></ul><p>而显然，右值引用就是这个所谓的待定类型。</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>对于一个类型 X，C++ 中使用 X&amp;&amp;来表示 X 的右值引用，而先前的 X&amp;则被称为左值引用。</p><p>右值引用与左值引用之间存在很多相似，而二者最明显的不同是，在函数重载的状况下，输入左值参数会优先匹配左值引用的函数重载，输入右值参数则会优先匹配右值引用的函数重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp; x)</span></span>;    <span class="hljs-comment">// 左值引用重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span></span>;   <span class="hljs-comment">// 右值引用重载</span><br><br>X x;<br><span class="hljs-function">X <span class="hljs-title">foobar</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">foo</span>(x);            <span class="hljs-comment">// 参数为左值，因此调用foo(X&amp; x)</span><br><span class="hljs-built_in">foo</span>(<span class="hljs-built_in">foobar</span>());     <span class="hljs-comment">// 参数为右值，因此调用foo(X&amp;&amp; x)</span><br></code></pre></td></tr></table></figure><p>因此右值引用的大致功能是：它让函数能够在编译期通过重载，区分出传入参数是左值还是右值。</p><p>任何函数都可以通过重载一个右值引用参数获得这个能力，但在大部分状况下，这种重载应当只出现在拷贝构造函数和拷贝赋值运算符中，并在重载内部实现语义的移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X <span class="hljs-type">const</span>&amp; rhs);    <span class="hljs-comment">// 默认的拷贝赋值运算符重载</span><br>X&amp; X::<span class="hljs-keyword">operator</span>=(X&amp;&amp; rhs) &#123;        <span class="hljs-comment">// 使用右值引用参数重载</span><br>    <span class="hljs-comment">// 实现移动语义：将rhs与this交换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>上述的移动语义实际上仍可改进，这会在强制移动语义上提到。</em></p><p>详细信息：</p><ul><li>对于函数 foo(X&amp;)：该函数允许传入左值参数，但不允许传入右值参数；</li><li>对于函数 foo(const X&amp;)：该函数允许传入左值参数和右值参数，但函数内部无法对参数的值类型进行区分；</li><li>对于函数 foo(X&amp;&amp;)：C++11 中，该函数允许传入右值参数，而不允许传入左值参数。</li></ul><h1 id="强制移动语义"><a href="#强制移动语义" class="headerlink" title="强制移动语义"></a>强制移动语义</h1><p>C++ 标准第一修正案规定：“委员会不得制定任何阻止 C++ 程序员自我陷害的规则。”换言之，C++ 会倾向给予程序员更多的控制权，而非从他们的粗心操作中保护他们。</p><p>遵循这一精神，C++11 允许程序员既可以在右值上使用移动语义，也可以根据判断在左值上使用。</p><p>一个很好的例子是 C++std 库函数 swap()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(a)</span></span>;<br>    a = b;<br>    b = tmp;<br>&#125;<br><br>X a, b;<br><span class="hljs-built_in">swap</span>(a, b);<br></code></pre></td></tr></table></figure><p>这一个 swap 函数中，三行赋值和构造函数都没有使用移动语义，但显然这里可以使用移动语义：当一个变量作为拷贝构造或拷贝赋值的源时，那个变量要么不再被使用，要么只被用作赋值的目标。</p><p>在 C++11 中，std 库函数中新增了 move()函数，该函数将输入的参数转换为一个右值，除此之外不做任何事情。因此在 C++11 中，库函数 swap 会类似这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在的 swap 函数中都使用了移动语义。</p><p><em>对于不实现移动语义的类型（即没有使用右值引用重载其拷贝构造函数&#x2F;赋值运算符），新 swap 函数的行为与旧的一样。</em></p><p>像上述一样使用 std::move 改写函数可以带来这些好处：</p><ul><li>对于实现了移动语义的类型，很多标准算法和操作都将使用移动语义，以获得显著的性能提升：比如就地的交换排序，使用移动语义能大大减少创建临时变量的开销。</li><li>C++STL 库中经常需要对那些可能用作容器元素的类型实施拷贝，而大多数情况下，比起拷贝，使用移动交换就足够了。因此在大部分环境中，当“可复制”的类型不足以实现目标时，我们可以使用“可移动”的类型（前者例如 unique_pointer）。</li></ul><p>在我们了解 std::move()函数后，我们发现先前提到的“使用右值引用重载拷贝复制运算符”这一实现仍有一部分问题。考虑一个两端都是变量的赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = b;<br></code></pre></td></tr></table></figure><p>你认为这个“&#x3D;”在用什么方式运行？你期待程序以这样的方式执行：a 对应的对象会被 b 的一个拷贝所覆盖，而在这一覆盖过程中，你还期待 a 覆盖前对应的对象执行其析构流程。</p><p>现在考虑这样的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = std::<span class="hljs-built_in">move</span>(b);<br></code></pre></td></tr></table></figure><p>如果这一移动语义的实现与简单的交换类似，那么语句仅会将 a 与 b 对应的对象进行呼唤，没有任何对象会执行其析构流程。</p><p>换言之，我们并不知道被先前被 a 持有的对象会在什么时候析构：一个变量已经被赋值了，但该变量赋值前拥有的对象依旧在内存的某个未知的位置存放着。对象的析构函数会存在一部分副作用，因此在右值引用重载的拷贝赋值运算符中，如果一个对象的析构函数存在额外作用，都需要对其进行显式调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X&amp;&amp; rhs) &#123;<br>    <span class="hljs-comment">// 实现对象的析构函数中的那些额外功能，保证使得对象能够被正常赋值和析构</span><br>    <span class="hljs-comment">// 实现移动语义</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="右值引用和右值"><a href="#右值引用和右值" class="headerlink" title="右值引用和右值"></a>右值引用和右值</h1><p>与先前一样，考虑类 X 使用移动语义重载了其拷贝构造函数和拷贝赋值运算符，对于以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span> </span>&#123;<br>    X anotherX = x;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了一个有趣的问题：在函数体 foo 中，X 的拷贝构造函数的哪个重载会被调用？这一代码中，x 是一个对 X 类型变量的右值引用，即 x 更有可能是一个右值的别名，因此，我们自然而然期待着 x 自己被赋值时也会与右值绑定，也就是期待其调用 X(X&amp;&amp; rhs)（经过右值引用重载的拷贝构造函数）。</p><p>换言之，我们期待一个右值引用本身也是一个右值。但右值引用的设计者采用了另一种更加微妙的解决方案：</p><p><em>被声明为右值引用的东西既可以是左值也可以是右值，区分其左值右值的方式是：如果它拥有一个名字，那么它是左值；反之则是右值。</em></p><p>对于上述的示例代码，函数体 foo 中的右值引用参数拥有一个名字 x，因此它是一个左值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span> </span>&#123;<br>    X anotherX = x; <span class="hljs-comment">// 调用拷贝构造函数 X(X const&amp; rhs)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下述示例则是使用了没有名字的右值引用，因此其为右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X&amp;&amp; <span class="hljs-title">goo</span><span class="hljs-params">()</span></span>;<br>X x = <span class="hljs-built_in">goo</span>();        <span class="hljs-comment">// 调用 X(X&amp;&amp;rhs)，因为赋值右侧的值没有名字</span><br></code></pre></td></tr></table></figure><p>这样设计的理由是：允许移动语义默认上能对有名字的变量使用，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X anotherX = x;    <span class="hljs-comment">// x仍在使用域中！</span><br></code></pre></td></tr></table></figure><p>移动语义最重要的一点是：只在其“不重要”时才会使用。这里有一条原则：“如果一个变量有名字，那么它是一个左值表达式”。</p><p>这个原则是否有另一部分：“如果一个变量没有名字，那么它是一个右值表达式”？</p><p>因此语句 std:move(x)会被视为一个右值引用，且并不拥有一个名字。因此它是一个右值。所以，std:move 的作用实际上是“将其接收的参数转为一个右值”，而它是通过“隐藏它的名字”来实现的。</p><p>下述示例用来展示“名字-左值关联”原则有多么重要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Parent</span>(Parent <span class="hljs-type">const</span>&amp; rhs);<br><span class="hljs-built_in">Parent</span>(Parent&amp;&amp; rhs);<br><br><span class="hljs-built_in">Child</span>(Child <span class="hljs-type">const</span> &amp; rhs) : <span class="hljs-built_in">Parent</span>(rhs) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">Child</span>(Child&amp;&amp; rhs) : <span class="hljs-built_in">Parent</span>(rhs) &#123; <span class="hljs-comment">// wrong, rhs是一个左值</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>Child（Child&amp;&amp; rhs) : <span class="hljs-built_in">Parent</span>(std::<span class="hljs-built_in">move</span>(rhs)) &#123; <span class="hljs-comment">//good, 这样才会调用基类的右值引用重载版本</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移动语义与编译器优化"><a href="#移动语义与编译器优化" class="headerlink" title="移动语义与编译器优化"></a>移动语义与编译器优化</h1><p>考虑下述的函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    X x;<br>    <span class="hljs-comment">// 可能对x进行一些操作</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>X 是一个用户自定义类，并且我们使用了移动语义，将其拷贝构造函数和拷贝赋值运算符进行了重载。从表面上看，你可能会想：“等等，return 语句执行时会产生一次拷贝，将 x 拷贝到了 foo 函数的返回值上。”</p><p>为了确认这一点，我们在 return 语句上使用移动语义来代替试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    X x;<br>    <span class="hljs-comment">// 可能对x进行一些操作</span><br>    <span class="hljs-keyword">return</span> std:<span class="hljs-built_in">move</span>(x);    <span class="hljs-comment">// warning: 请勿使用move返回局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024-10-09/4aacdc9046cd/"/>
    <url>/2024-10-09/4aacdc9046cd/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
