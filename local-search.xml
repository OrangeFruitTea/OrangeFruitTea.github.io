<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>A*寻路算法</title>
    <link href="/2024-10-10/142c5063b9b6/"/>
    <url>/2024-10-10/142c5063b9b6/</url>
    
    <content type="html"><![CDATA[<h1 id="A-寻路"><a href="#A-寻路" class="headerlink" title="A*寻路"></a>A*寻路</h1><p>A*寻路有如下特点：</p><p><strong>基于网格</strong></p><p>A*寻路算法是基于格子的寻路算法，即算法会把地图看作多个格子组成，寻得的路径也是一连串相邻格子组成的路径。</p><p><strong>启发式</strong></p><p>对于一个网格，假设操作目标能四向移动，如何让程序知道往哪个格子走能更接近终点？如果能在每次移动前做一次评估，根据评估获得的值进行比较，取评估值最合适的格子进行移动，理论上就能达到这一目的。</p><p>这一思路被称为启发式，指通过评估找到合适的路径，即优先搜索最有可能产生最佳路径的格子。</p><h2 id="A-寻路的组成"><a href="#A-寻路的组成" class="headerlink" title="A*寻路的组成"></a>A*寻路的组成</h2><h3 id="估价-评估函数"><a href="#估价-评估函数" class="headerlink" title="估价&#x2F;评估函数"></a>估价&#x2F;评估函数</h3><p>先前提到算法需要对移动的方向进行评估获取估价值，因此需要编写一个估价函数进行计算。</p><p>对于任意一个格子 n，其估价计算函数为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">f</span>(n) = <span class="hljs-built_in">g</span>(n) + <span class="hljs-built_in">h</span>(n)<br></code></pre></td></tr></table></figure><p>g(n)指从起点到格子 n 的实际代价，h(n)是从格子 n 到终点的估计代价。</p><p><img src="/static/MaHpbKVMlokmwYxKGLScfSiynGb.png"></p><p>对于上述图片例子的三个格子，计算 f(n)值的流程是：</p><ul><li><p>格子 1：</p><ul><li>起点至格子 1 需移动 1 格，g(1) &#x3D; 1；</li><li>格子 1 到终点的直线距离为 6 格，h(1) &#x3D; 6；</li><li>f(1) &#x3D; 1 + 6 &#x3D; 7。</li></ul></li><li><p>同理得格子 2 的估价：f(2) &#x3D; g(2) + h(2) &#x3D; 1 + 4 &#x3D; 5</p></li><li><p>格子 3 的估价：f(3) &#x3D; g(3) + h(3) &#x3D; √2 + √17</p></li></ul><p>因此优先考虑去往格子 2 的情况。</p><p>上述对 h(n)的计算采用了简单的直线距离计算（即使用欧几里得距离），h(n)的值永远 &lt;&#x3D;格子 n 到终点的最短实际距离。但这样计算时会出现大量的平方与开根号的计算，并且需要采用浮点数，性能差。因此根据实际情况往往使用的是曼哈顿距离或对角线 + 直线的距离。</p><p>曼哈顿距离简单来说是只允许水平垂直移动的最短距离，因此曼哈顿距离肯定 &gt;&#x3D;格子 n 到终点的最短实际距离。</p><p>另一种加快运算的方式是，假设两个格子之间的单位距离 L，然后直接认为对角线距离为 1.4L，从而避免浮点数和根号运算。</p><h4 id="h-n-的影响"><a href="#h-n-的影响" class="headerlink" title="h(n)的影响"></a>h(n)的影响</h4><p>总地来说：</p><ul><li>如果 h(n) &lt;&#x3D; n 到终点的实际距离，A*算法可以找到最短路径，但搜索的点数多，搜索范围大，效率低；</li><li>如果 h(n) &gt; n 到终点的实际距离，搜索的点数少，搜索范围小，效率高，但是得到的路径并不一定是最短的。</li><li>h(n) 越接近 n 到终点的实际距离，那么 A*算法越完美。（个人理解是如果用曼哈顿距离，那么只需要找到一条长度小于等于该距离的路径就算完成任务了。而使用对角线距离就要找到一条长度大于等于对角线距离且最短的路径才行。）</li><li>若 h(n)&#x3D;0，即 f(n)&#x3D;g(n)，A*算法就变为了 Dijkstra 算法（Dijstra 算法会毫无方向的向四周搜索）。</li><li>若 h(n) 远远大于 g(n) ，那么 f(n) 的值就主要取决于 h(n)，A*算法就演变成了广度优先遍历算法。</li></ul><p>因此在启发式寻路算法中，估价函数十分重要，尤其是其中的 h(n)部分。</p><h3 id="A-寻路流程"><a href="#A-寻路流程" class="headerlink" title="A*寻路流程"></a>A*寻路流程</h3><h4 id="简述版"><a href="#简述版" class="headerlink" title="简述版"></a>简述版</h4><ul><li><p>预备两个列表 openList 与 closeList 储存对应的地图格；</p></li><li><p>将起点格加入开启列表 openList 中；</p></li><li><p>重复以下流程：</p><ul><li>遍历 openList，寻找 openList 中 f(n)最小的结点，将其设置为当前处理结点；</li><li>将当前处理结点移动至 closeList；</li><li>对当前处理结点的每个相邻结点：<ul><li>若其不可达或已在 closeList 中，将其忽略；</li><li>若其不在 openList 中，将其加入 openList，把当前处理结点设置为其父结点，并记录当前处理结点的 F、G 和 H 值；</li><li>若其已在 openList 中，检查当前处理结点到其的路径是否更好：依据计算出的 G 值进行参考，更小的 G 值表示更好的路径；若如此，将其父节点设置为当前处理结点，并重新计算其 G 值与 F 值，并可能需要对 openList 重新排序；</li></ul></li></ul></li><li><p>停止，当：</p><ul><li>终点被加入到 openList 中，此时找到了路径；</li><li>查找终点失败，并且 openList 为空，此时没有路径；</li></ul></li><li><p>保存路径，从终点开始，每个结点沿着其父结点移动至起点。</p></li></ul><h4 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h4><p>由于 A*寻路算法的核心为其估价函数，因此需要一个结构&#x2F;类储存如下信息：对象对应的网格 ID、该网格的 F、G、H 值及其父结点。以下是伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> id, Node* parent, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> h)<br>        : <span class="hljs-built_in">Id</span>(id), <span class="hljs-built_in">Parent</span>(parent), <span class="hljs-built_in">g</span>(g), <span class="hljs-built_in">h</span>(h) &#123;<br>            f = <span class="hljs-built_in">calF</span>(g, h); <span class="hljs-comment">//构造函数内部的估价函数</span><br>    &#125;<br>    <span class="hljs-type">int</span> Id;<br>    Node* Parent;<br>    <br>    <span class="hljs-comment">//</span><br>    <span class="hljs-type">int</span> g;    <span class="hljs-comment">// 父节点到该网格的实际距离</span><br>    <span class="hljs-type">int</span> h;    <span class="hljs-comment">// 该网格至终点的估计距离 / 估计值</span><br>    <span class="hljs-type">int</span> f;    <span class="hljs-comment">// 该网格的总估价值</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">calF</span><span class="hljs-params">(<span class="hljs-type">int</span> g, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-comment">// 实现估价函数计算</span><br>        <span class="hljs-keyword">return</span> g + h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要两个数据结构 openList 与 closeList 储存格子，前者储存将要被计算估值的格子，后者储存已经被计算估值的格子。</p><h2 id="改进-A-寻路"><a href="#改进-A-寻路" class="headerlink" title="改进 A*寻路"></a>改进 A*寻路</h2><h3 id="改进估价函数"><a href="#改进估价函数" class="headerlink" title="改进估价函数"></a>改进估价函数</h3><h4 id="选择预估函数"><a href="#选择预估函数" class="headerlink" title="选择预估函数"></a>选择预估函数</h4><h4 id="为函数增加权重"><a href="#为函数增加权重" class="headerlink" title="为函数增加权重"></a>为函数增加权重</h4><h4 id="结点比较时的优化"><a href="#结点比较时的优化" class="headerlink" title="结点比较时的优化"></a>结点比较时的优化</h4><h3 id="优化搜索邻域"><a href="#优化搜索邻域" class="headerlink" title="优化搜索邻域"></a>优化搜索邻域</h3><h3 id="使用双向搜索"><a href="#使用双向搜索" class="headerlink" title="使用双向搜索"></a>使用双向搜索</h3><h3 id="优化数据结构"><a href="#优化数据结构" class="headerlink" title="优化数据结构"></a>优化数据结构</h3><p>显然在算法逻辑中需要对 openList 与 closeList 进行频繁的增删和查询；</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>右值引用浅析</title>
    <link href="/2024-10-10/b27fcb36e098/"/>
    <url>/2024-10-10/b27fcb36e098/</url>
    
    <content type="html"><![CDATA[<h1 id="【C-11】右值引用解析"><a href="#【C-11】右值引用解析" class="headerlink" title="【C++11】右值引用解析"></a>【C++11】右值引用解析</h1><p>参考并翻译自 <a href="http://thbecker.net/articles/rvalue_references/section_01.html">Thoma’s Becker’s overview</a>（2013）。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>右值与右值引用是在 c++11 中新增的特性。在首次了解右值引用时很难看出设计这一特性的目的、解决了什么问题等，因此下文通过罗列编程中产生的（推动 C++ 设计右值引用的）问题，了解右值引用是怎么解决它们的。</p><p>右值引用解决了至少两个问题：</p><ul><li>移动语义</li><li>完美转发</li></ul><p>首先是移动语义。在描述这一问题前，需要先了解 C++ 中的左值与右值。</p><p>C 语言中对左值右值一开始的定义是：左值指能出现在赋值运算符左侧或右侧的表达式，右值则是只能出现在赋值运算符的右侧的表达式。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">42</span>；<br><span class="hljs-type">int</span> b = <span class="hljs-number">43</span>; <span class="hljs-comment">// a与b都是左值表达式</span><br>a = b;      <span class="hljs-comment">// ok</span><br>b = a;      <span class="hljs-comment">// ok</span><br>a = a * b;  <span class="hljs-comment">// ok</span><br><span class="hljs-comment">// a * b是右值表达式</span><br><span class="hljs-type">int</span> c = a * b; <span class="hljs-comment">// ok</span><br>a * b = <span class="hljs-number">42</span>;    <span class="hljs-comment">// error，右值表达式不能位于赋值运算符左侧</span><br></code></pre></td></tr></table></figure><p>C++ 在一开始时也同样沿用了这一定义，但在 C++ 中使用用户自定义类型并对其进行修改和赋值时，可能会出现一些微妙地不符合该定义的情况。</p><p>下述是一个可选的对左值右值的定义；这个定义依旧有不准确之处，但足够帮助你理解 C++ 的右值引用：</p><p>C++ 中，所有表达式不是左值表达式就是右值表达式；当一个表达式是左值表达式时，它对应着内存中的某个地址，并且允许我们通过&amp;操作符获得它的地址；而不是左值表达式的表达式都是右值表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>i = <span class="hljs-number">43</span>;             <span class="hljs-comment">// i为左值表达式</span><br><span class="hljs-type">int</span>* p = &amp;i;        <span class="hljs-comment">// ok, i为左值表达式，可取地址</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">foo</span>() = <span class="hljs-number">42</span>;         <span class="hljs-comment">// ok, foo() 也为左值表达式</span><br><span class="hljs-type">int</span>* p1 = &amp;<span class="hljs-built_in">foo</span>();   <span class="hljs-comment">// ok, 能够对foo()取地址</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foobar</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>j = <span class="hljs-built_in">foobar</span>();       <span class="hljs-comment">// ok, foobar()为右值表达式</span><br><span class="hljs-type">int</span>* p2 = &amp;<span class="hljs-built_in">foobar</span>();<span class="hljs-comment">// error, 不能对右值表达式取地址</span><br>j = <span class="hljs-number">42</span>;             <span class="hljs-comment">// ok, 42是一个右值表达式</span><br></code></pre></td></tr></table></figure><h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>假设 X 是一个类，它持有指向某种资源的指针或句柄，比如 m_pResource（这里的资源指任何需要花费大量努力去构造、克隆或销毁的东西）；一个很好的例子是 std::vector，它持有一系列对象，这些对象存在于分配的内存数组中。</p><p>与拷贝构造函数类似，假设 X 在代码中被这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>X x;<br><span class="hljs-comment">// 对x的部分操作和使用</span><br>x = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>对于最后一行代码，程序执行如下操作：</p><ul><li>克隆由 foo 返回的临时变量及其资源；</li><li>销毁 x 持有的资源，并使用克隆的变量替换它；</li><li>销毁 foo 返回的临时资源从而将其释放。</li></ul><p>可以得到一般的拷贝运算符的执行方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X <span class="hljs-type">const</span>&amp; rhs) &#123;<br>  <span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 对rhs.m_pResource指向的资源创建一次拷贝</span><br>  <span class="hljs-comment">// Destruct the resource that m_pResource refers to. </span><br>  <span class="hljs-comment">// Attach the clone to m_pResource.</span><br>  <span class="hljs-comment">// [...]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述步骤，程序出现了一次拷贝：对 foo()的返回值拷贝了一次临时变量，而后又将这一临时变量销毁。显然，存在一个更有效率的执行方式：交换 x 与 foo 返回的临时变量之间的资源指针，然后让临时变量的析构函数销毁 x 的原始资源。换句话说，当赋值运算符右侧是右值时，我们希望拷贝赋值运算符应该这么执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 交换 m-pResource 与 rhs.m_pResource</span><br>  <span class="hljs-comment">// [...]</span><br></code></pre></td></tr></table></figure><p>这就是 C++11 引入的_移动语义_。在 C++11 中，使用以下重载可以重载到移动语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(&lt;待定类型&gt; rhs) &#123;<br>  <span class="hljs-comment">// [...]</span><br>  <span class="hljs-comment">// 交换 m-pResource 与 rhs.m_pResource</span><br>  <span class="hljs-comment">// [...]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们在重载一个拷贝赋值运算符，因此这个“待定类型”必须是引用类型：我们希望 rhs 参数是按引用传递的；同时，我们希望这个“待定类型”能做到这个操作：</p><ul><li>使用左值表达式作为参数时，程序会调用正常版的拷贝（使用 const type &amp;类型）；使用右值表达式作为参数时，程序调用移动语义重载后的拷贝（使用待定类型）。</li></ul><p>而显然，右值引用就是这个所谓的待定类型。</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>对于一个类型 X，C++ 中使用 X&amp;&amp;来表示 X 的右值引用，而先前的 X&amp;则被称为左值引用。</p><p>右值引用与左值引用之间存在很多相似，而二者最明显的不同是，在函数重载的状况下，输入左值参数会优先匹配左值引用的函数重载，输入右值参数则会优先匹配右值引用的函数重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp; x)</span></span>;    <span class="hljs-comment">// 左值引用重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span></span>;   <span class="hljs-comment">// 右值引用重载</span><br><br>X x;<br><span class="hljs-function">X <span class="hljs-title">foobar</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">foo</span>(x);            <span class="hljs-comment">// 参数为左值，因此调用foo(X&amp; x)</span><br><span class="hljs-built_in">foo</span>(<span class="hljs-built_in">foobar</span>());     <span class="hljs-comment">// 参数为右值，因此调用foo(X&amp;&amp; x)</span><br></code></pre></td></tr></table></figure><p>因此右值引用的大致功能是：它让函数能够在编译期通过重载，区分出传入参数是左值还是右值。</p><p>任何函数都可以通过重载一个右值引用参数获得这个能力，但在大部分状况下，这种重载应当只出现在拷贝构造函数和拷贝赋值运算符中，并在重载内部实现语义的移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X <span class="hljs-type">const</span>&amp; rhs);    <span class="hljs-comment">// 默认的拷贝赋值运算符重载</span><br>X&amp; X::<span class="hljs-keyword">operator</span>=(X&amp;&amp; rhs) &#123;        <span class="hljs-comment">// 使用右值引用参数重载</span><br>    <span class="hljs-comment">// 实现移动语义：将rhs与this交换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>上述的移动语义实际上仍可改进，这会在强制移动语义上提到。</em></p><p>详细信息：</p><ul><li>对于函数 foo(X&amp;)：该函数允许传入左值参数，但不允许传入右值参数；</li><li>对于函数 foo(const X&amp;)：该函数允许传入左值参数和右值参数，但函数内部无法对参数的值类型进行区分；</li><li>对于函数 foo(X&amp;&amp;)：C++11 中，该函数允许传入右值参数，而不允许传入左值参数。</li></ul><h1 id="强制移动语义"><a href="#强制移动语义" class="headerlink" title="强制移动语义"></a>强制移动语义</h1><p>C++ 标准第一修正案规定：“委员会不得制定任何阻止 C++ 程序员自我陷害的规则。”换言之，C++ 会倾向给予程序员更多的控制权，而非从他们的粗心操作中保护他们。</p><p>遵循这一精神，C++11 允许程序员既可以在右值上使用移动语义，也可以根据判断在左值上使用。</p><p>一个很好的例子是 C++std 库函数 swap()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(a)</span></span>;<br>    a = b;<br>    b = tmp;<br>&#125;<br><br>X a, b;<br><span class="hljs-built_in">swap</span>(a, b);<br></code></pre></td></tr></table></figure><p>这一个 swap 函数中，三行赋值和构造函数都没有使用移动语义，但显然这里可以使用移动语义：当一个变量作为拷贝构造或拷贝赋值的源时，那个变量要么不再被使用，要么只被用作赋值的目标。</p><p>在 C++11 中，std 库函数中新增了 move()函数，该函数将输入的参数转换为一个右值，除此之外不做任何事情。因此在 C++11 中，库函数 swap 会类似这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在的 swap 函数中都使用了移动语义。</p><p><em>对于不实现移动语义的类型（即没有使用右值引用重载其拷贝构造函数&#x2F;赋值运算符），新 swap 函数的行为与旧的一样。</em></p><p>像上述一样使用 std::move 改写函数可以带来这些好处：</p><ul><li>对于实现了移动语义的类型，很多标准算法和操作都将使用移动语义，以获得显著的性能提升：比如就地的交换排序，使用移动语义能大大减少创建临时变量的开销。</li><li>C++STL 库中经常需要对那些可能用作容器元素的类型实施拷贝，而大多数情况下，比起拷贝，使用移动交换就足够了。因此在大部分环境中，当“可复制”的类型不足以实现目标时，我们可以使用“可移动”的类型（前者例如 unique_pointer）。</li></ul><p>在我们了解 std::move()函数后，我们发现先前提到的“使用右值引用重载拷贝复制运算符”这一实现仍有一部分问题。考虑一个两端都是变量的赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = b;<br></code></pre></td></tr></table></figure><p>你认为这个“&#x3D;”在用什么方式运行？你期待程序以这样的方式执行：a 对应的对象会被 b 的一个拷贝所覆盖，而在这一覆盖过程中，你还期待 a 覆盖前对应的对象执行其析构流程。</p><p>现在考虑这样的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = std::<span class="hljs-built_in">move</span>(b);<br></code></pre></td></tr></table></figure><p>如果这一移动语义的实现与简单的交换类似，那么语句仅会将 a 与 b 对应的对象进行呼唤，没有任何对象会执行其析构流程。</p><p>换言之，我们并不知道被先前被 a 持有的对象会在什么时候析构：一个变量已经被赋值了，但该变量赋值前拥有的对象依旧在内存的某个未知的位置存放着。对象的析构函数会存在一部分副作用，因此在右值引用重载的拷贝赋值运算符中，如果一个对象的析构函数存在额外作用，都需要对其进行显式调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X&amp;&amp; rhs) &#123;<br>    <span class="hljs-comment">// 实现对象的析构函数中的那些额外功能，保证使得对象能够被正常赋值和析构</span><br>    <span class="hljs-comment">// 实现移动语义</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="右值引用和右值"><a href="#右值引用和右值" class="headerlink" title="右值引用和右值"></a>右值引用和右值</h1><p>与先前一样，考虑类 X 使用移动语义重载了其拷贝构造函数和拷贝赋值运算符，对于以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span> </span>&#123;<br>    X anotherX = x;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了一个有趣的问题：在函数体 foo 中，X 的拷贝构造函数的哪个重载会被调用？这一代码中，x 是一个对 X 类型变量的右值引用，即 x 更有可能是一个右值的别名，因此，我们自然而然期待着 x 自己被赋值时也会与右值绑定，也就是期待其调用 X(X&amp;&amp; rhs)（经过右值引用重载的拷贝构造函数）。</p><p>换言之，我们期待一个右值引用本身也是一个右值。但右值引用的设计者采用了另一种更加微妙的解决方案：</p><p><em>被声明为右值引用的东西既可以是左值也可以是右值，区分其左值右值的方式是：如果它拥有一个名字，那么它是左值；反之则是右值。</em></p><p>对于上述的示例代码，函数体 foo 中的右值引用参数拥有一个名字 x，因此它是一个左值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X&amp;&amp; x)</span> </span>&#123;<br>    X anotherX = x; <span class="hljs-comment">// 调用拷贝构造函数 X(X const&amp; rhs)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下述示例则是使用了没有名字的右值引用，因此其为右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X&amp;&amp; <span class="hljs-title">goo</span><span class="hljs-params">()</span></span>;<br>X x = <span class="hljs-built_in">goo</span>();        <span class="hljs-comment">// 调用 X(X&amp;&amp;rhs)，因为赋值右侧的值没有名字</span><br></code></pre></td></tr></table></figure><p>这样设计的理由是：允许移动语义默认上能对有名字的变量使用，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">X anotherX = x;    <span class="hljs-comment">// x仍在使用域中！</span><br></code></pre></td></tr></table></figure><p>移动语义最重要的一点是：只在其“不重要”时才会使用。这里有一条原则：“如果一个变量有名字，那么它是一个左值表达式”。</p><p>这个原则是否有另一部分：“如果一个变量没有名字，那么它是一个右值表达式”？</p><p>因此语句 std:move(x)会被视为一个右值引用，且并不拥有一个名字。因此它是一个右值。所以，std:move 的作用实际上是“将其接收的参数转为一个右值”，而它是通过“隐藏它的名字”来实现的。</p><p>下述示例用来展示“名字-左值关联”原则有多么重要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Parent</span>(Parent <span class="hljs-type">const</span>&amp; rhs);<br><span class="hljs-built_in">Parent</span>(Parent&amp;&amp; rhs);<br><br><span class="hljs-built_in">Child</span>(Child <span class="hljs-type">const</span> &amp; rhs) : <span class="hljs-built_in">Parent</span>(rhs) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">Child</span>(Child&amp;&amp; rhs) : <span class="hljs-built_in">Parent</span>(rhs) &#123; <span class="hljs-comment">// wrong, rhs是一个左值</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>Child（Child&amp;&amp; rhs) : <span class="hljs-built_in">Parent</span>(std::<span class="hljs-built_in">move</span>(rhs)) &#123; <span class="hljs-comment">//good, 这样才会调用基类的右值引用重载版本</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="移动语义与编译器优化"><a href="#移动语义与编译器优化" class="headerlink" title="移动语义与编译器优化"></a>移动语义与编译器优化</h1><p>考虑下述的函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    X x;<br>    <span class="hljs-comment">// 可能对x进行一些操作</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>X 是一个用户自定义类，并且我们使用了移动语义，将其拷贝构造函数和拷贝赋值运算符进行了重载。从表面上看，你可能会想：“等等，return 语句执行时会产生一次拷贝，将 x 拷贝到了 foo 函数的返回值上。”</p><p>为了确认这一点，我们在 return 语句上使用移动语义来代替试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    X x;<br>    <span class="hljs-comment">// 可能对x进行一些操作</span><br>    <span class="hljs-keyword">return</span> std:<span class="hljs-built_in">move</span>(x);    <span class="hljs-comment">// warning: 请勿使用move返回局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024-10-09/4aacdc9046cd/"/>
    <url>/2024-10-09/4aacdc9046cd/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
